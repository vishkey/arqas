{
    "contents" : "#' Checks if a object belongs to a determinate package\n#' \n#' @param obj Object to check\n#' @param packagename Name of the package\n#' @return TRUE if obj belongs to the package, FALSE if not\n#' @keywords internal\nbelong <- function(obj, packagename) {\n  if (length(obj) > 1)\n    packageobj <- sapply(lapply(obj, class), attr, \"package\")\n  else\n    packageobj <- attr(class(obj), \"package\")\n  \n  return(all(packageobj==packagename))\n}\n\n#' Obtains the main characteristics of a G/G/1 model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter used to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/1 model:\n#' \\item{pn}{Stores all the positives steady-state probabilities of having n customers, with n from 0 to staClients+nClients}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and  \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\n\nG_G_1 <- function(arrivalDistribution = Exp(1), serviceDistribution = Exp(1), staClients = 100, nClients = 1000, historic = FALSE) {\n      if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n      if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n      if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n      if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n      \n      tArr <- r(arrivalDistribution) (staClients+nClients)\n      tServ <- r(serviceDistribution) (staClients+nClients)\n      iArr <- iServ <- 1\n      sysClients <- simClients<- 0\n      a <- 0\n      b <- -1\n      \n      obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Nclients=nClients)\n      if (historic) hist <- matrix(nrow=nClients, ncol=6, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\", \"Clients\", \"Intensity\")))\n      \n      while (simClients < staClients) {\n        if (sysClients > 0)\n          tMin <- min(a, b)\n        else\n          tMin <- a\n\n        if (tMin == a) {\n          simClients <- simClients + 1     \n          if (sysClients == 0) {\n            b <- tServ[iServ]\n            iServ <- iServ+1\n          } else\n            b <- b - tMin\n          a <- tArr[iArr]\n          iArr <- iArr + 1\n          sysClients <- sysClients+1\n        } else {\n          sysClients <- sysClients - 1\n          if (sysClients == 0) {\n            b <- -1\n          } else {\n            b <- tServ[iServ]\n            iServ <- iServ + 1\n          }\n          a <- a - tMin\n        }\n      }\n      simClients <- 0\n      cron <- d <- c <- 0\n      tnClients <- numeric(nClients)\n      actualper <- seq(0, 100, 10)\n      percentages <- (actualper*nClients)/100\n      iper <- 1 \n      while (simClients < nClients) {\n        if (simClients > percentages[iper]) {\n          iper <- iper+1\n          message(paste(actualper[iper], \"%\", sep=\"\"))\n        }\n        if (sysClients > 0) {\n          tMin <- min(a, b)\n        }\n        else {\n          tMin <- a\n        }\n        cron <- cron + tMin\n        tnClients[sysClients+1] <- tnClients[sysClients+1] + tMin\n\n        \n        if (tMin == a) {\n            simClients <- simClients + 1\n            if (sysClients == 0) {\n                b <- tServ[iServ]\n                iServ <- iServ+1\n            }\n            else {\n                c <- c + tMin*sysClients\n                d <- d + tMin*(sysClients-1)\n                b <- b - tMin\n            }\n            sysClients <- sysClients+1\n            a <- tArr[iArr]\n            iArr <- iArr + 1\n        }\n        else {\n            c <- c + tMin*sysClients\n            d <- d + tMin*(sysClients-1)\n            \n            sysClients <- sysClients - 1\n            if (sysClients == 0) {\n              b <- -1\n            } else {\n              b <- tServ[iServ]\n              iServ <- iServ + 1\n            }\n            a <- a - tMin\n        }\n        #En cada iteraciÃ³n almacenamos la evolucion de los valores\n        if (historic) {\n          l <- c/cron\n          lq <- d/cron\n          w <- c/nClients\n          wq <- d/nClients\n  \n          hist[simClients, ] <- c(l,lq,w,wq, sysClients, l-lq)\n        }\n      }\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      eff <- w/(w-wq)\n      rho <- l-lq\n      pn <- tnClients[1:max(which(tnClients>0))]/cron\n      if (historic)\n        obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      else\n        obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      oldClass(obj) <-  c(\"G_G_1\", \"SimulatedModel\")\n      \n      return(obj)\n}\n\nexportToUI(G_G_1, \"G/G/1\",  c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"boolean\"),  c(\"G_G_1\", \"SimulatedModel\"))\n\n#' Obtains the main characteristics of a G/G/s model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param s Number of servers\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter used to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/S model:\n#' \\item{pn}{vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\n\nG_G_S <- function (arrivalDistribution=Exp(1), serviceDistribution=Exp(1), s=2, staClients=100, nClients=1000, historic=FALSE) {\n      if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n      if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n      if (s <= 0) stop(\"Argument 's' must be greather than 0.\")\n      if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n      if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n      \n      tArr <- r(arrivalDistribution) (nClients+staClients)\n      tServ <- r(serviceDistribution) (nClients+staClients)\n      iArr <-1\n      iServ <- 0\n      bussyservs <- numeric()\n      sysClients <- simClients<- 0\n      cron <- d <- c <- 0\n     \n      obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Servs=s, Nclients=nClients)\n      tnClients <- numeric(nClients)\n      if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n      \n      while(simClients < staClients) {\n        if (sysClients > 0) {\n          if (length(bussyservs) > 0)\n            tmin <- min(tArr[iArr], min(tServ[bussyservs]))\n          else\n            tmin <- tArr[iArr]\n        }\n        else tmin <- tArr[iArr]\n        \n        if (tmin == tArr[iArr]) {\n          simClients <- simClients + 1\n          iArr <- iArr + 1    \n          #if exists any server free\n          if (sysClients < s) {\n            sysClients <- sysClients + 1\n            #update the time of the servers working\n            if (length(bussyservs) > 0)\n              tServ[bussyservs] <- tServ[bussyservs] - tmin\n            #Add a new server to the array\n            iServ <- iServ+1\n            bussyservs <- c(bussyservs, iServ)\n          } else {\n            sysClients <- sysClients + 1\n            if (length(bussyservs) > 0)\n              tServ[bussyservs] <- tServ[bussyservs] - tmin\n          }\n        }else {\n          finishserver <- which.min(tServ[bussyservs])\n          sysClients <- sysClients-1\n          if (length(bussyservs) > 0)\n            tServ[bussyservs] <- tServ[bussyservs] - tmin\n          \n          bussyservs <- bussyservs[-finishserver]\n          if (sysClients >= s) {\n            iServ <- iServ+1\n            bussyservs <- c(bussyservs, iServ)\n          }\n          tArr[iArr] <- tArr[iArr] - tmin\n        }\n      }\n      simClients <- 0\n      while(simClients < nClients) {\n        #print(bussyservs)\n        #Check what type of event happen\n        if (sysClients > 0) {\n          if (length(bussyservs) > 0)\n            tmin <- min(tArr[iArr], min(tServ[bussyservs]))\n          else\n            tmin <- tArr[iArr]\n        }\n        else tmin <- tArr[iArr]\n        \n        if (tmin == tArr[iArr]) {\n          simClients <- simClients + 1\n          cron <- cron + tmin\n          tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n          iArr <- iArr + 1\n          c <- c + tmin*sysClients     \n          #if exists any server free\n          if (sysClients < s) {\n            sysClients <- sysClients + 1\n            #update the time of the servers working\n            if (length(bussyservs) > 0)\n              tServ[bussyservs] <- tServ[bussyservs] - tmin\n            #Add a new server to the array\n            iServ <- iServ+1\n            bussyservs <- c(bussyservs, iServ)\n          } else {\n            d <- d + tmin*(sysClients-s)\n            sysClients <- sysClients + 1\n            if (length(bussyservs) > 0)\n              tServ[bussyservs] <- tServ[bussyservs] - tmin\n          }\n        }else {\n           finishserver <- which.min(tServ[bussyservs])\n           cron <- cron + tmin\n           c <- c + tmin*sysClients\n           \n           if (sysClients > s)\n             d <- d + tmin*(sysClients-s)\n           \n           tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n           sysClients <- sysClients-1\n           if (length(bussyservs) > 0)\n              tServ[bussyservs] <- tServ[bussyservs] - tmin\n           \n           bussyservs <- bussyservs[-finishserver]\n           if (sysClients >= s) {\n             iServ <- iServ+1\n             bussyservs <- c(bussyservs, iServ)\n           }\n           tArr[iArr] <- tArr[iArr] - tmin\n        }\n        #En cada iteraciÃ³n almacenamos la evolucion de los valores\n        if (historic) {\n          l <- c/cron\n          lq <- d/cron\n          w <- c/nClients\n          wq <- d/nClients\n          \n          hist[simClients, ] <- c(l,lq,w,wq)\n        }\n      }\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      eff <- w/(w-wq)\n      rho <- (l-lq)/s\n      pn <- tnClients[1:max(which(tnClients>0))]/cron\n      if (historic)\n        obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      else\n        obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      oldClass(obj) <-  c(\"G_G_S\", \"SimulatedModel\")\n      \n      return(obj)\n}\n\nexportToUI(G_G_S, \"G/G/s\", c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"),  c(\"G_G_S\", \"SimulatedModel\"))\n\n#'Obtains the main characteristics of a G/G/1/K model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param K Maximun size of the queue\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/1/K model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation.}\n#' @export\n#' @family SimulatedModels\n\nG_G_1_K <- function (arrivalDistribution=Exp(1), serviceDistribution=Exp(1), K=2, staClients=100, nClients=1000, historic=FALSE) {\n      if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n      if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n      if (K <= 0) stop(\"Argument 'K' must be greather than 0.\")\n      if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n      if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n      \n      tArr <- r(arrivalDistribution) ((nClients+staClients)*2)\n      tServ <- r(serviceDistribution) ((nClients+staClients)*2)\n      iArr <- iServ <- 1\n      sysClients <- simClients<- 0\n      cron <- d <- c <- 0\n      tnClients <- numeric(nClients)\n      \n      obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Nclients=nClients)\n      if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n      \n      while(simClients < staClients) {\n        \n        if (sysClients > 0) {\n          tmin <- min(tArr[iArr], tServ[iServ])\n        } else {\n          tmin <- tArr[iArr]\n        }\n        \n        \n        if(tmin == tArr[iArr]) {\n          iArr <- iArr + 1\n          \n          if (sysClients == (K+1)) {\n            tServ[iServ] <- tServ[iServ] - tmin\n            \n          } else {\n            simClients <- simClients + 1\n            if (sysClients == 0)ciServ <- iServ + 1\n            else tServ[iServ] <- tServ[iServ] - tmin\n  \n            sysClients <- sysClients + 1\n          }\n        } else {\n          sysClients <- sysClients - 1\n          \n          if(sysClients != 0) {\n            iServ <- iServ + 1\n          }\n          tArr[iArr] <- tArr[iArr] - tmin\n        }\n      }\n      simClients <- 0\n      \n      while(simClients < nClients) {\n        \n        if (sysClients > 0) {\n          tmin <- min(tArr[iArr], tServ[iServ])\n        } else {\n          tmin <- tArr[iArr]\n        }\n        \n        \n        if(tmin == tArr[iArr]) { \n          cron <- cron + tmin\n          tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n          iArr <- iArr + 1\n          \n          if (sysClients == (K+1)) {\n            tServ[iServ] <- tServ[iServ] - tmin\n            c <- c + tmin*sysClients\n            d <- d + tmin*(sysClients-1)\n           \n          } else {\n            simClients <- simClients + 1\n            if (sysClients == 0) {\n              sysClients <- sysClients + 1\n              iServ <- iServ + 1\n            } else {\n              c <- c+tmin*sysClients\n              d <- d+tmin*(sysClients-1)\n              sysClients <- sysClients + 1\n              tServ[iServ] <- tServ[iServ] - tmin\n            }\n          }\n        } else {\n          cron <- cron + tmin\n          c <- c + tmin*sysClients\n          d <- d + tmin*(sysClients-1)\n          tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n          sysClients <- sysClients - 1\n          \n          if(sysClients != 0) {\n            iServ <- iServ + 1\n          }\n          tArr[iArr] <- tArr[iArr] - tmin\n        }\n        #En cada iteraciÃ³n almacenamos la evolucion de los valores\n        if (historic) {\n          l <- c/cron\n          lq <- d/cron\n          w <- c/nClients\n          wq <- d/nClients\n          hist[simClients, ] <- c(l,lq,w,wq)\n        }\n      }\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      rho <- l-lq\n      eff <- w/(w-wq)\n      pn <- tnClients[1:max(which(tnClients>0))]/cron\n      if (historic)\n        obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      else\n        obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      oldClass(obj) <-  c(\"G_G_1_K\", \"SimulatedModel\")\n      \n      return(obj)\n}\n\nexportToUI(G_G_1_K, \"G/G/1/K\", c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"), c(\"G_G_1_K\", \"SimulatedModel\"))\n\n#' Obtains the main characteristics of a G/G/s/K model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param s Number of servers\n#' @param K Maximun size of the queue\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/S/K model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W}and \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\n\nG_G_S_K <- function(arrivalDistribution=Exp(1), serviceDistribution=Exp(1), s=2, K=3, staClients=100, nClients=1000, historic=FALSE) {\n      if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n      if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n      if (s <= 0) stop(\"Argument 's' must be greather than 0.\")\n      if (K <= 0) stop(\"Argument 'K' must be greather than 0.\")\n      if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n      if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n      \n      tArr <- r(arrivalDistribution) ((nClients+staClients)*2)\n      tServ <- r(serviceDistribution) ((nClients+staClients)*2)\n      iArr <- iServ <- 1\n      bussyservers <- rep(NA, s)\n      sysClients <- simClients<- 0\n      cron <- d <- c <- 0\n      \n      obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Servs=s, Nclients=nClients)\n      tnClients <- numeric(nClients)\n      if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n      \n      while(simClients < staClients) {\n        indice_min_b <- which.min(bussyservers)\n        \n        if (sysClients > 0) \n          tmin <- min(tArr[iArr], bussyservers[indice_min_b])\n        else\n          tmin <- tArr[iArr]\n        \n        if (tmin == tArr[iArr]) {\n          if(sysClients == (K+s)){\n            iArr <- iArr + 1\n            bussyservers <- bussyservers-tmin\n          } else {\n            simClients <- simClients + 1\n            if (sysClients < s) {\n              sysClients <- sysClients + 1\n              iArr <- iArr + 1\n              bussyservers <- bussyservers - tmin\n              bussyservers[which(is.na(bussyservers))[1]] <- tServ[iServ]\n              iServ <- iServ + 1\n            } else {\n              sysClients <- sysClients + 1\n              iArr <- iArr + 1\n              bussyservers <- bussyservers-tmin\n            }\n          }\n        } else {\n          sysClients <- sysClients - 1\n        \n          bussyservers <- bussyservers-tmin\n          if (sysClients < s)\n            bussyservers[indice_min_b] <- NA\n          else {\n            bussyservers[indice_min_b] <- tServ[iServ]\n            iServ <- iServ + 1\n          }\n          tArr[iArr] <- tArr[iArr] - tmin\n        }\n      }\n      simClients <- 0\n      \n      while(simClients < nClients) {\n        indice_min_b <- which.min(bussyservers)\n        \n        if (sysClients > 0) \n          tmin <- min(tArr[iArr], bussyservers[indice_min_b])\n        else\n          tmin <- tArr[iArr]\n        \n        if (tmin == tArr[iArr]) {\n          cron <- cron + tmin\n          tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n          iArr <- iArr + 1\n          c <- c + tmin*sysClients\n          if(sysClients == (K+s)){\n            d <- d + tmin*(sysClients-s)\n            bussyservers <- bussyservers-tmin\n          } else {\n            simClients <- simClients + 1\n            if (sysClients < s) {\n              sysClients <- sysClients + 1\n              iArr <- iArr + 1\n              bussyservers <- bussyservers - tmin\n              bussyservers[which(is.na(bussyservers))[1]] <- tServ[iServ]\n              iServ <- iServ + 1\n            } else {\n              d <- d + tmin*(sysClients-s)\n              sysClients <- sysClients + 1\n              bussyservers <- bussyservers-tmin\n            }\n          }\n        } else {\n          cron <- cron + tmin\n          c <- c + tmin*sysClients\n          if (sysClients > s)\n            d <- d + tmin*(sysClients-s)\n          \n          tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n          sysClients <- sysClients - 1\n          \n          bussyservers <- bussyservers-tmin\n          if (sysClients < s)\n            bussyservers[indice_min_b] <- NA\n          else {\n            bussyservers[indice_min_b] <- tServ[iServ]\n            iServ <- iServ + 1\n          }\n          tArr[iArr] <- tArr[iArr] - tmin\n        }\n        #En cada iteraciÃ³n almacenamos la evolucion de los valores\n        if (historic) {\n          l <- c/cron\n          lq <- d/cron\n          w <- c/nClients\n          wq <- d/nClients\n          \n          hist[simClients, ] <- c(l,lq,w,wq)\n        }\n      }\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      rho <- (l-lq)/s\n      eff <- w/(w-wq)\n      pn <- tnClients[1:max(which(tnClients>0))]/cron\n      if (historic)\n        obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      else\n        obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      oldClass(obj) <-  c(\"G_G_S_K\", \"SimulatedModel\")\n      \n      return(obj)\n}\n\nexportToUI(G_G_S_K, \"G/G/s/K\",  c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"),  c(\"G_G_S_K\", \"SimulatedModel\"))\n\n#' Obtains the main characteristics of a G/G/1/\\eqn{\\infty}/H model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param H Population size\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/1/\\eqn{\\infty}/H model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\n\nG_G_1_INF_H <- function(arrivalDistribution=Exp(1), serviceDistribution=Exp(1), H=2, staClients=100, nClients=1000, historic=FALSE) {\n    if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n    if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n    if (H <= 0) stop(\"Argument 'H' must be greather than 0.\")\n    if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n    if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n    \n    tArr <- r(arrivalDistribution) ((nClients+staClients)*2)\n    tServ <- r(serviceDistribution) ((nClients+staClients)*2)\n    possibleClients <- tArr[1:H]\n    iServ <- 1\n    iArr <- H+1\n    sysClients <- 0\n    simClients <- 0\n    \n    obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, H=H, Nclients=nClients)\n    tnClients <- numeric(nClients)\n    if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n    \n    while(simClients < staClients) {\n      indice_minimo_a <- which.min(possibleClients)\n      \n      if(sysClients>0)\n        minimo<-min(possibleClients[indice_minimo_a], tServ[iServ])\n      else\n        minimo<-possibleClients[indice_minimo_a]\n      \n      if (length(indice_minimo_a) == 0 || minimo==tServ[iServ]) {\n        sysClients <- sysClients-1\n        if (sysClients==0)\n          tServ[iServ] <- -1\n        else\n          iServ <- iServ + 1\n        possibleClients<-possibleClients-minimo\n        possibleClients[which(is.na(possibleClients))]<- tArr[iArr]\n        iArr <- iArr+1\n      } else {\n        simClients<-simClients+1\n        \n        if(sysClients==0) {\n          sysClients<-sysClients+1\n          possibleClients <-possibleClients-minimo\n          possibleClients[indice_minimo_a]<- NA\n          iServ <- iServ + 1\n        } else{\n          sysClients<-sysClients+1\n          tServ[iServ]<-tServ[iServ]-minimo\n          possibleClients<-possibleClients-minimo\n          possibleClients[indice_minimo_a]<- NA\n        }\n      }\n    }\n    \n    simClients <- cron <- c <- d <- 0\n\n    while(simClients < nClients) {\n      indice_minimo_a <- which.min(possibleClients)\n      \n      if (sysClients>0)\n        minimo <- min(possibleClients[indice_minimo_a],tServ[iServ])\n      else\n        minimo <- possibleClients[indice_minimo_a]\n      \n      if (length(indice_minimo_a) == 0 || minimo==tServ[iServ]) {\n        cron <- cron + minimo\n        c <- c + minimo*sysClients\n        d <- d + minimo*(sysClients-1)\n        tnClients[sysClients+1] <- tnClients[sysClients+1]+minimo\n        sysClients<-sysClients-1\n        if (sysClients==0)\n          tServ[iServ] <- -1\n        else\n          iServ <- iServ + 1\n        possibleClients<-possibleClients-minimo\n        possibleClients[which(is.na(possibleClients))[1]]<- tArr[iArr]\n        iArr <- iArr + 1\n      } else {\n        simClients <- simClients+1\n        \n        if (sysClients==0) {\n          cron <- cron + minimo\n          tnClients[sysClients+1] <- tnClients[sysClients+1]+minimo\n          sysClients <- sysClients+1\n          possibleClients <- possibleClients-minimo\n          possibleClients[indice_minimo_a]<- NA\n          iServ <- iServ + 1\n        } else {\n          cron <- cron+minimo\n          c <- c + minimo*sysClients\n          d <- d + minimo*(sysClients-1)\n          tnClients[sysClients+1] <- tnClients[sysClients+1]+minimo\n          sysClients <- sysClients+1\n          tServ[iServ] <- tServ[iServ]-minimo\n          possibleClients<-possibleClients-minimo\n          possibleClients[indice_minimo_a]<- NA\n        }\n      }\n      #En cada iteraciÃ³n almacenamos la evolucion de los valores\n      if (historic) {\n        l <- c/cron\n        lq <- d/cron\n        w <- c/nClients\n        wq <- d/nClients\n        \n        hist[simClients, ] <- c(l,lq,w,wq)\n      }\n    }\n    l <- c/cron\n    lq <- d/cron\n    w <- c/nClients\n    wq <- d/nClients\n    rho <- l - lq\n    eff <- w/(w-wq)\n    pn <- tnClients[1:max(which(tnClients>0))]/cron\n    if (historic)\n      obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n    else\n      obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n    \n    oldClass(obj) <-  c(\"G_G_1_INF_H\", \"SimulatedModel\")\n    return(obj)\n}\n\nexportToUI(G_G_1_INF_H, \"G/G/1/INF/H\", c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"), c(\"G_G_1_INF_H\", \"SimulatedModel\"))\n\n#' Obtains the main characteristics of a G/G/S/\\eqn{\\infty}/H  model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param s Number of servers\n#' @param H Population size\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/S/\\eqn{\\infty}/H model\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\n\nG_G_S_INF_H <- function(arrivalDistribution=Exp(1), serviceDistribution=Exp(1), s=2, H=2, staClients=100, nClients=1000, historic=FALSE) {\n      if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n      if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n      if (s <= 0) stop(\"Argument 's' must be greather than 0.\")\n      if (H <= 0) stop(\"Argument 'H' must be greather than 0.\")\n      if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n      if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n  \n      tArr <- r(arrivalDistribution) ((nClients+staClients)*2)\n      tServ <- r(serviceDistribution) ((nClients+staClients)*2)\n      possibleClients <- tArr[1:H]\n      bussyservers <- rep(NA, s)\n      iServ <- 1\n      iArr <- H+1\n      sysClients <- 0\n      simClients <- 0\n      nClicien <- 100/nClients\n      obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Servs=s, H=H, Nclients=nClients)\n      tnClients <- numeric(nClients)\n      if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n      \n      while(simClients < staClients) {        \n        if(sysClients>0) {\n          indice_minimo_a <- which.min(possibleClients)\n          indice_minimo_b <- which.min(bussyservers)\n          tmin <- min(possibleClients[indice_minimo_a], bussyservers[indice_minimo_b])\n        }\n        else {\n          indice_minimo_a <- which.min(possibleClients)\n          tmin <- possibleClients[indice_minimo_a]\n        }\n        \n        if (length(indice_minimo_a > 0) && (tmin == possibleClients[indice_minimo_a])) {\n          simClients <- simClients + 1\n          if (sysClients < s) {\n            sysClients <- sysClients + 1\n            possibleClients <- possibleClients - tmin\n            possibleClients[indice_minimo_a] <- NA\n            bussyservers <- bussyservers - tmin\n            bussyservers[which(is.na(bussyservers))[1]] <- tServ[iServ]\n            iServ <- iServ + 1\n          } else {\n            sysClients <- sysClients + 1\n            bussyservers <- bussyservers - tmin\n            possibleClients <- possibleClients - tmin\n            possibleClients[indice_minimo_a] <- NA\n          }\n        } else {\n          sysClients <- sysClients - 1 \n          bussyservers <- bussyservers-tmin\n          if (sysClients < s)\n            bussyservers[indice_minimo_b] <- NA\n          else {\n            bussyservers[indice_minimo_b] <- tServ[iServ]\n            iServ <- iServ + 1\n          }\n          possibleClients <- possibleClients - tmin\n          possibleClients[which(is.na(possibleClients))[1]] <- tArr[iArr]\n          iArr <- iArr+1\n        }\n      }\n      simClients <- cron <- c <- d <- 0\n      progressbar <- txtProgressBar(min=0, max=nClients, style=3)\n      auxProg <- !(((0:nClients)/nClients*100) %% 5)\n      jump <- 10\n      while (simClients < nClients) {\n        if (auxProg[simClients+1]) setTxtProgressBar(progressbar, simClients)\n        if(sysClients>0) {\n          indice_minimo_a <- which.min(possibleClients)\n          indice_minimo_b <- which.min(bussyservers)\n          tmin <- min(possibleClients[indice_minimo_a], bussyservers[indice_minimo_b])\n        }\n        else {\n          indice_minimo_a <- which.min(possibleClients)\n          tmin <- possibleClients[indice_minimo_a]\n        }\n        \n        if (length(indice_minimo_a > 0) && (tmin == possibleClients[indice_minimo_a])) {\n          simClients <- simClients + 1\n          if (sysClients < s) {\n            cron <- cron + tmin\n            tnClients[sysClients+1] <- tnClients[sysClients+1]+tmin\n            c <- c + tmin*sysClients\n            sysClients <- sysClients + 1\n            possibleClients <- possibleClients - tmin\n            possibleClients[indice_minimo_a] <- NA\n            bussyservers <- bussyservers - tmin\n            bussyservers[which(is.na(bussyservers))[1]] <- tServ[iServ]\n            iServ <- iServ + 1\n          } else {\n            cron <- cron + tmin\n            tnClients[sysClients+1] <- tnClients[sysClients+1]+tmin\n            c <- c + tmin*sysClients\n            d <- d + tmin*(sysClients-s)\n            sysClients <- sysClients + 1\n            bussyservers <- bussyservers - tmin\n            possibleClients <- possibleClients - tmin\n            possibleClients[indice_minimo_a] <- NA\n          }\n        } else {\n          cron <- cron + tmin\n          c <- c + tmin*sysClients\n          if (sysClients > s)\n            d <- d + tmin*(sysClients-s)\n          tnClients[sysClients+1] <- tnClients[sysClients+1]+tmin\n          sysClients <- sysClients - 1 \n          bussyservers <- bussyservers - tmin\n          if (sysClients < s)\n            bussyservers[indice_minimo_b] <- NA\n          else {\n            bussyservers[indice_minimo_b ] <- tServ[iServ]\n            iServ <- iServ + 1\n          }\n          possibleClients <- possibleClients - tmin\n          possibleClients[which(is.na(possibleClients))[1]] <- tArr[iArr]\n          iArr <- iArr+1\n        } \n        #En cada iteraciÃ³n almacenamos la evolucion de los valores\n        if (historic) {\n          l <- c/cron\n          lq <- d/cron\n          w <- c/nClients\n          wq <- d/nClients\n          \n          hist[simClients, ] <- c(l,lq,w,wq)\n        }\n      }\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      rho <- l - lq\n      eff <- w/(w-wq)\n      pn <- tnClients[1:max(which(tnClients>0))]/cron\n      if (historic)\n        obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      else\n        obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n      oldClass(obj) <-  c(\"G_G_S_INF_H\", \"SimulatedModel\")\n      close(progressbar)\n      return(obj)\n}\n\nexportToUI(G_G_S_INF_H, \"G/G/s/INF/H\", c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"), c(\"G_G_S_INF_H\", \"SimulatedModel\"))\n\n#' Obtains the main characteristics of a G/G/S/\\eqn{\\infty}/H with Y replacements model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param s Number of servers\n#' @param H Population size\n#' @param Y Number of replacements\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/1/S/\\eqn{\\infty}/H/Y model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\nG_G_S_INF_H_Y <- function(arrivalDistribution=Exp(1), serviceDistribution=Exp(1), s=2, H=2, Y=3, staClients=100, nClients=1000, historic=FALSE) {\n  if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n  if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n  if (s <= 0) stop(\"Argument 's' must be greather than 0.\")\n  if (H <= 0) stop(\"Argument 'H' must be greather than 0.\")\n  if (Y <= 0) stop(\"Argument 'Y' must be greather than 0.\")\n  if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n  if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n  \n  tArr <- r(arrivalDistribution) ((nClients+staClients)*2)\n  tServ <- r(serviceDistribution) ((nClients+staClients)*2)\n  possibleClients <- tArr[1:H]\n#   bussyservers <- rep(-1, s)\n  bussyservers <- rep(NA, s)\n  iServ <- 1\n  iArr <- H+1\n  sysClients <- 0\n  simClients <- 0\n  \n  obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Servs=s, H=H, Y=Y, Nclients=nClients)\n  tnClients <- numeric(nClients)\n  if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n  \n  while(simClients < staClients) {    \n    if(sysClients>0) {\n      indice_minimo_b <- which.min(bussyservers)\n      indice_minimo_a <- which.min(possibleClients)\n      tmin <- min(possibleClients[indice_minimo_a], bussyservers[indice_minimo_b])\n    }else {\n      indice_minimo_a <- which.min(possibleClients)\n      tmin <- possibleClients[indice_minimo_a]\n    }\n    \n    if (length(indice_minimo_a) > 0 && (tmin == possibleClients[indice_minimo_a])) {\n      simClients <- simClients + 1\n      if (sysClients < s) {\n        sysClients <- sysClients + 1\n        possibleClients <- possibleClients - tmin\n        possibleClients[indice_minimo_a] <- NA\n\n        bussyservers <- bussyservers - tmin\n        bussyservers[which(is.na(bussyservers))[1]] <- tServ[iServ]\n        iServ <- iServ + 1\n        if (sysClients <= Y) {\n          possibleClients[indice_minimo_a] <- tArr[iArr]\n          iArr <- iArr + 1\n        }\n      } else {\n        sysClients <- sysClients + 1\n        bussyservers <- bussyservers - tmin\n        possibleClients <- possibleClients - tmin\n        possibleClients[indice_minimo_a] <- NA\n        if (sysClients <= Y) {\n          possibleClients[indice_minimo_a] <- tArr[iArr]\n          iArr <- iArr + 1\n        }\n      }\n    } else {\n      sysClients <- sysClients - 1 \n      bussyservers <- bussyservers - tmin\n      if (sysClients < s)\n        bussyservers[indice_minimo_b] <- NA\n      else {\n        bussyservers[indice_minimo_b ] <- tServ[iServ]\n        iServ <- iServ + 1\n      }\n      possibleClients <- possibleClients - tmin\n      if (sysClients >= Y) {\n        possibleClients[which(is.na(possibleClients))[1]] <- tArr[iArr]\n        iArr <- iArr+1\n      }\n    }\n  }\n  simClients <- cron <- c <- d <- 0\n  while (simClients < nClients) {\n    \n    if(sysClients>0) {\n      indice_minimo_b <- which.min(bussyservers)\n      indice_minimo_a <- which.min(possibleClients)\n      tmin <- min(possibleClients[indice_minimo_a], bussyservers[indice_minimo_b])\n    } else {\n      indice_minimo_a <- which.min(possibleClients)\n      tmin <- possibleClients[indice_minimo_a]\n    }\n\n    \n    if (length(indice_minimo_a) > 0 && (tmin == possibleClients[indice_minimo_a])) {\n      simClients <- simClients + 1\n      if (sysClients < s) {\n        cron <- cron + tmin\n        tnClients[sysClients+1] <- tnClients[sysClients+1]+tmin\n        c <- c + tmin*sysClients\n        sysClients <- sysClients + 1\n        possibleClients <- possibleClients - tmin\n        possibleClients[indice_minimo_a] <- NA\n        if (sysClients <= Y) {\n          possibleClients[indice_minimo_a] <- tArr[iArr]\n          iArr <- iArr + 1\n        }\n        bussyservers <- bussyservers - tmin\n        bussyservers[which(is.na(bussyservers))[1]] <- tServ[iServ]\n        iServ <- iServ + 1\n      } else {\n        cron <- cron + tmin\n        tnClients[sysClients+1] <- tnClients[sysClients+1]+tmin\n        c <- c + tmin*sysClients\n        d <- d + tmin*(sysClients-s)\n        sysClients <- sysClients + 1\n        bussyservers <- bussyservers - tmin\n        possibleClients <- possibleClients - tmin\n        possibleClients[indice_minimo_a] <- NA\n        if (sysClients <= Y) {\n          possibleClients[indice_minimo_a] <- tArr[iArr]\n          iArr <- iArr + 1\n        }\n      }\n    } else {\n      cron <- cron + tmin\n      c <- c + tmin*sysClients\n      if (sysClients > s)\n        d <- d + tmin*(sysClients-s)\n      tnClients[sysClients+1] <- tnClients[sysClients+1]+tmin\n      sysClients <- sysClients - 1 \n      bussyservers <- bussyservers - tmin\n      if (sysClients < s)\n        bussyservers[indice_minimo_b] <- NA\n      else {\n        bussyservers[indice_minimo_b ] <- tServ[iServ]\n        iServ <- iServ + 1\n      }\n      possibleClients <- possibleClients - tmin\n      if (sysClients >= Y) {\n        possibleClients[which(is.na(possibleClients))[1]] <- tArr[iArr]\n        iArr <- iArr+1\n      }\n    } \n    #En cada iteraciÃ³n almacenamos la evolucion de los valores\n    if (historic) {\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      \n      hist[simClients, ] <- c(l,lq,w,wq)\n    }\n  }\n  l <- c/cron\n  lq <- d/cron\n  w <- c/nClients\n  wq <- d/nClients\n  rho <- (l - lq)/s\n  eff <- w/(w-wq)\n  pn <- tnClients[1:max(which(tnClients>0))]/cron\n  if (historic)\n    obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n  else\n    obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n  \n  oldClass(obj) <-  c(\"G_G_S_INF_H_Y\", \"SimulatedModel\")\n  return(obj)\n}\n\nexportToUI(G_G_S_INF_H_Y, \"G/G/s/INF/H with Y replacements\", c(\"distr\", \"distr\", \"numeric\", \"numeric\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"),  c(\"G_G_S_INF_H_Y\", \"SimulatedModel\"))\n\n#' Obtains the main characteristics of a G/G/\\eqn{\\infty} model by simulation\n#' \n#' @param arrivalDistribution Arrival distribution\n#' @param serviceDistribution Service distribution\n#' @param staClients Number of customers used in stabilization stage\n#' @param nClients Number of customers used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a G/G/\\eqn{\\infty} model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation}\n#' @export\n#' @family SimulatedModels\nG_G_INF <- function(arrivalDistribution=Exp(1), serviceDistribution=Exp(1), staClients=100, nClients=1000, historic=FALSE) {\n  if (!belong(arrivalDistribution, \"distr\")) stop(\"Argument 'arrivalDistribution' must be a valid Class of the Distr package\")\n  if (!belong(serviceDistribution, \"distr\")) stop(\"Argument 'serviceDistribution'must be a valid Class of the Distr package\")\n  if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n  if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n  \n  tArr <- r(arrivalDistribution) ((nClients+staClients)*2)\n  tServ <- r(serviceDistribution) ((nClients+staClients)*2)\n  iServ <- iArr <- 1\n  sysClients <- 0\n  simClients <- 0\n  a <- 0\n  b <- -1\n  \n  obj <- list(arrivalDistribution = arrivalDistribution, serviceDistribution=serviceDistribution, Nclients=nClients)\n  tnClients <- numeric(nClients)\n  if (historic) hist <- matrix(nrow=nClients, ncol=4, dimnames=list(1:nClients, c(\"L\", \"Lq\", \"W\",\"Wq\")))\n  \n  while(simClients < staClients) {\n    indice_j <- which(b != -1)\n    indice_j_menos_uno <- which(b==-1)\n    \n    if (length(indice_j_menos_uno) == 0) {\n      b <- c(b, -1)\n      indice_j_menos_uno <- length(b)\n    }\n    \n    if (sysClients > 0) {\n      posibles_b <- b[indice_j]\n      tmin <- min(a, posibles_b)\n    } else\n      tmin <- a\n    \n    if (tmin == a) {\n      simClients <- simClients + 1\n      sysClients <- sysClients + 1\n      a <- tArr[iArr]\n      iArr <- iArr + 1\n      b[indice_j] <- b[indice_j] - tmin\n      b[indice_j_menos_uno[1]] <- tServ[iServ]\n      iServ <- iServ + 1\n    } else {\n      indice_minimo <- which(b==tmin)\n      sysClients <- sysClients - 1\n      b[indice_j] <- b[indice_j] - tmin\n      b[indice_minimo] <- -1\n      a <- a - tmin\n    }\n  }\n  simClients <- cron <- c <- d <- 0\n  \n  while(simClients < nClients) {\n    #print(simClients)\n    indice_j <- which(b != -1)\n    indice_j_menos_uno <- which(b==-1)\n    \n    if (length(indice_j_menos_uno) == 0) {\n      b <- c(b, -1)\n      indice_j_menos_uno <- length(b)\n    }\n    \n    if (sysClients > 0) {\n      posibles_b <- b[indice_j]\n      tmin <- min(a, posibles_b)\n    } else\n      tmin <- a\n    \n    cron <- cron + tmin\n    tnClients[sysClients+1] <- tnClients[sysClients+1] + tmin\n    if (tmin == a) {\n      simClients <- simClients + 1\n      c <- c + tmin*sysClients\n      sysClients <- sysClients + 1\n      a <- tArr[iArr]\n      iArr <- iArr + 1\n      b[indice_j] <- b[indice_j] - tmin\n      b[indice_j_menos_uno[1]] <- tServ[iServ]\n      iServ <- iServ + 1\n    } else {\n      indice_minimo <- which(b==tmin)\n      c <- c + tmin*sysClients\n      sysClients <- sysClients - 1\n      b[indice_j] <- b[indice_j] - tmin\n      b[indice_minimo] <- -1\n      a <- a - tmin\n    }\n    #En cada iteraciÃ³n almacenamos la evolucion de los valores\n    if (historic) {\n      l <- c/cron\n      lq <- d/cron\n      w <- c/nClients\n      wq <- d/nClients\n      \n      hist[simClients, ] <- c(l,lq,w,wq)\n    }\n  }\n  l <- c/cron\n  lq <- d/cron\n  w <- c/nClients\n  wq <- d/nClients\n  rho <- l - lq\n  eff <- w/(w-wq)\n  pn <- tnClients[1:max(which(tnClients>0))]/cron\n  if (historic)\n    obj$out <- list(historic=hist, l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n  else\n    obj$out <- list(l=l, lq=lq, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n  oldClass(obj) <-  c(\"G_G_INF\", \"SimulatedModel\")\n  \n  return(obj)\n}\n\nexportToUI(G_G_INF, \"G/G/INF\", c(\"distr\", \"distr\", \"numeric\",\"numeric\", \"boolean\"),  c(\"G_G_INF\", \"SimulatedModel\"))\n\nSCN_example <- function (sta, trans) {\n  serviceDistribution <- c(Exp(5), Exp(5), Exp(10), Exp(15))\n  s <- c(2,2,1,1)\n  p <- array(c(0.25,0.15,0.5,0.4,0.15,0.35,0.25,0.3,0.2,0.2,0.15,0.25,0.4,0.30,0.1,0.05), dim=c(4,4))\n  nClients <- 3\n  ClosedNetwork(serviceDistribution, s, p, sta, nClients, trans)\n}\n\n#' Obtains the main characteristics of a Closed Network model by simulation\n#' \n#' @param serviceDistribution Service distributions for the nodes of the network\n#' @param s Vector of servers at each node\n#' @param p Routing matrix, where \\eqn{p_{ij}} is the routing probability from node i to node j\n#' @param staClients Number of customers used in the stabilization stage\n#' @param nClients Number of customers in the system\n#' @param transitions Number of transitions between nodes used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of a Closed Network model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Vector of expected number of customers in the nodes \\eqn{L}}\n#' \\item{lq}{Vector of expected number of customers in the queues of the nodes \\eqn{L_{q}}}\n#' \\item{lqt}{Expected number of customers in the all queues}\n#' \\item{w}{Vector of expected waiting times in the nodes \\eqn{W}}\n#' \\item{wq}{Vector of expected waiting times in the queues of the nodes \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of \\eqn{L}, \\eqn{Lq}, \\eqn{W} and \\eqn{Wq} during the simulation.}\n#' @export\n#' @family SimulatedModels\n\nClosedNetwork <- function(serviceDistribution, s, p, staClients, nClients, transitions, historic=FALSE) {\n  if (!belong(serviceDistribution, \"distr\")) stop(\"All elements in argument 'serviceDistribution'must be a valid Class of the Distr package\")\n  if (any(s <= 0)) stop(\"All elements in argument 's' must be greather than 0.\")\n  if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n  if (nClients <= 0) stop(\"Argument 'nClients' must be greather than 0.\")\n  if (transitions <= 0) stop(\"Argument 'transitions' must be greather than 0.\")\n  \n  ini <- proc.time()[3]\n  nodes <- length(s)\n  maxserv <- max(s)\n  map <- function(f) {f(staClients+transitions)}\n  tServ <- matrix(sapply(lapply(serviceDistribution, r), map, simplify=TRUE), nrow=((staClients+transitions)*2), ncol=nodes )\n  iServ <- rep(1, nodes)\n  rand <- r(Unif()) (staClients+transitions)\n  simClients <- 0\n  \n  obj <- list(serviceDistribution=serviceDistribution, Servs= s, Prob=p, Nclients=nClients)\n  if (historic) hist <- array(dim=c(nodes, 4, transitions), dimnames=list(1:nodes, c(\"L\", \"Lq\", \"W\",\"Wq\"), 1:transitions))\n  \n  sysClients <- floor((nClients-1)*(s^(-1))/sum(s^-1))\n  res <- nClients-sum(sysClients)\n  sysClients[1:res] <- sysClients[1:res] + 1\n  \n  b <- matrix(nrow=maxserv, ncol=nodes)\n  for(i in 1:nodes) {\n    if (s[i] > sysClients[i]) {\n      if (sysClients[i] == 0) next\n      b[1:sysClients[i], i] <- tServ[1:sysClients[i], i]\n      iServ[i] <- iServ[i] + sysClients[i]\n    } else {\n      b[1:s[i],i] <- tServ[1:s[i],i]\n      iServ[i] <- iServ[i] + s[i]\n    }\n  }\n  ini <- proc.time()[3] - ini\n  estab <- proc.time()[3]\n  while (simClients < staClients) {\n    indice_minimo_b <- which.min(b) #al ser los libre NA, devuelve el indice menor del que no es NA\n    tmin <- b[indice_minimo_b]\n    nodex <- ceiling(indice_minimo_b/maxserv)\n    \n    simClients <- simClients + 1\n    sysClients[nodex] <- sysClients[nodex] - 1\n    b <- b - tmin  #los NA siguen siendo NA al restar\n    \n    if (sysClients[nodex] < s[nodex]) {\n      b[indice_minimo_b] <- NA\n    } else {\n      b[indice_minimo_b] <- tServ[iServ[nodex], nodex]\n      iServ[nodex] <- iServ[nodex] + 1\n    }\n    \n    n_s <- rand[simClients]\n    acum <- 0\n    j <- 1\n    while (acum < n_s) {\n      acum <- acum + p[nodex, j]\n      j <- j+1\n    }\n    j <- j-1\n    \n    sysClients[j] <- sysClients[j] + 1\n    if (sysClients[j] <= s[j]) {\n      indice_minimo_nodo_minimo <- which(is.na(b[,j]))\n      b[indice_minimo_nodo_minimo[1], j] <- tServ[iServ[j], j]\n      iServ[j] <- iServ[j] + 1\n    }\n  }\n  simClients <- cron <- 0\n  c <- d <- in_node <- rep(0, nodes)\n  prob <- matrix(c(0), nrow=transitions, ncol=nodes)\n  estab <- proc.time()[3] - estab\n  simula <- proc.time()[3]\n  while(simClients < transitions) {    \n    indice_minimo_b <- which.min(b) #al ser los libre NA, devuelve el indice menor del que no es NA\n    tmin <- b[indice_minimo_b]\n    nodex <- ceiling(indice_minimo_b/maxserv)\n    simClients <- simClients + 1\n    sysClients[nodex] <- sysClients[nodex] - 1\n\n    b <- b - tmin\n    \n    if (sysClients[nodex] < s[nodex]) {\n      b[indice_minimo_b] <- NA\n    } else {\n      b[indice_minimo_b] <- tServ[iServ[nodex], nodex]\n      iServ[nodex] <- iServ[nodex] + 1\n    }\n    \n    n_s <- rand[simClients+staClients]\n    acum <- 0\n    node_dest <- 1\n    while (acum < n_s) {\n      acum <- acum + p[nodex, node_dest]\n      node_dest <- node_dest+1\n    }\n    node_dest <- node_dest-1\n    sysClients[node_dest] <- sysClients[node_dest] + 1\n    in_node[node_dest] <- in_node[node_dest]+ 1\n    \n    if (sysClients[node_dest] <= s[node_dest]) {\n      indice_minimo_nodo_minimo <- which(is.na(b[,node_dest]))\n      b[indice_minimo_nodo_minimo[1], node_dest] <- tServ[iServ[node_dest], node_dest]\n      iServ[node_dest] <- iServ[node_dest] + 1\n    }\n    \n    cron <- cron + tmin\n    for (j in 1:nodes) {\n      if ((j == nodex) && (j != node_dest)) {\n        c[j] <- c[j]+tmin*(sysClients[j]+1)\n        if ((sysClients[j]+1) > s[j])\n          d[j] <- d[j]+tmin*(sysClients[j]+1-s[j])\n        prob[sysClients[j]+2, j] <- prob[sysClients[j]+2,j] + tmin\n      } else {\n        if ((j == node_dest) && (j != nodex)) {\n          c[j] <- c[j] + tmin*(sysClients[j]-1)\n          if ((sysClients[j]-1) > s[j])\n            d[j] <- d[j] + tmin*(sysClients[j]-1-s[j])\n          prob[sysClients[j], j] <- prob[sysClients[j], j] + tmin\n        } else {\n          c[j] <- c[j] + tmin*sysClients[j]\n          if (sysClients[j] > s[j])\n            d[j] <- d[j] + tmin*(sysClients[j]-s[j])\n          prob[sysClients[j]+1, j] <- prob[sysClients[j]+1, j] + tmin\n        }\n      }\n    }\n    if (historic) {\n      l <- c/cron\n      lq <- d/cron\n      w <- c/in_node\n      wq <- d/in_node\n      hist[,,simClients] <- array(c(l, lq, w, wq), dim= c(nodes, 4))\n    }\n  }\n  simula <- proc.time()[3] - simula\n  l <- c/cron\n  lq <- d/cron\n  w <- c/in_node\n  wq <- d/in_node\n  lqt <- sum(lq)\n  rho <- l - lq\n  eff <- w/(w-wq)\n  pn <- prob/cron\n  obj$out <- list(l=l, lq=lq, lqt=lqt, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n  #obj$out$data <- array(c(l, lq, w, wq), dim= c(nodes, 4), dimnames=list(1:nodes, c(\"L\", \"Lq\", \"W\", \"Wq\")))\n  if (historic) {\n    obj$out$historic <- hist\n  }\n  oldClass(obj) <-  c(\"Closed\", \"SimulatedNetwork\", \"SimulatedModel\")\n  \n  return(obj)\n}\n\nexportToUI(ClosedNetwork, \"Closed Network\", c(\"Vdistr\", \"vector\", \"matrix\", \"numeric\", \"numeric\", \"numeric\", \"boolean\"), c(\"Closed\", \"SimulatedNetwork\", \"SimulatedModel\"))\n\nSON_Example <- function (sta, trans) {\n  p <- matrix(c(0.2, 0.25, 0.1, 0), nrow=2, ncol=2)\n  s <- c(1, 2)\n  arrivalDistribution <- pairlist(c(Exp(20), Exp(30)), c(1,2))\n  serviceDistribution <- c(Exp(100), Exp(25))\n  OpenNetwork(arrivalDistribution, serviceDistribution, s, p, sta, trans)\n}\n\n#' Obtains the main characteristics of an Open Network model by simulation\n#'  \n#' @param arrivalDistribution PairList indicating the arrival distribution and the node that uses it.\n#' @param serviceDistribution Vector of service distribution in each node\n#' @param s Vector of servers in each node\n#' @param p Routing matrix, where \\eqn{p_{ij}} is the routing probability from node i to node j\n#' @param staClients Number of customers used in the stabilization stage\n#' @param transitions Number of transitions between nodes used in the simulation stage\n#' @param historic Parameter to activate/deactivate the historic information\n#' @return\n#' Returns the next information of an Open network model:\n#' \\item{pn}{Vector of steady-state probabilities of having n customers in the system \\eqn{P(n)}}\n#' \\item{l}{Vector of expected number of customers in the nodes \\eqn{L}}\n#' \\item{lq}{Vector of expected number of customers in the queues of the nodes \\eqn{L_{q}}}\n#' \\item{lqt}{Expected number of customers in all queues}\n#' \\item{w}{Vector of expected waiting times in the nodes \\eqn{W}}\n#' \\item{wq}{Vector of expected waiting time in the queues of the nodes \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-Wq)}}\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{historic}{Optional parameter that stores the evolution of L, Lq, W and Wq during the simulation.}\n#' @export\n#' @family SimulatedModels\n\n         \nOpenNetwork <- function(arrivalDistribution, serviceDistribution, s, p, staClients, transitions, historic=FALSE) {\n  if (!belong(serviceDistribution, \"distr\")) stop(\"All elements in argument 'serviceDistribution'must be a valid Class of the Distr package\")\n  if (!belong(arrivalDistribution[[1]], \"distr\")) stop(\"All elements in first position of argument 'serviceDistribution'must be a valid Class of the Distr package\")\n  if (any(s <= 0)) stop(\"All elements in argument 's' must be greather than 0.\")\n  if (staClients <= 0) stop(\"Argument 'staClients' must be greather than 0.\")\n  if (transitions <= 0) stop(\"Argument 'transitions' must be greather than 0.\")\n  \n  nodes <- length(s)\n  maxserv <- max(s)\n  #Adaptamos la matriz de probabilidades para tener encuenta las salidas\n  p <- matrix(c(1-rowSums(p), as.vector(p)), nrow=nrow(p), ncol=ncol(p)+1)\n  #raux <- function(v) {if (is.na(v)) return(NA) else return(r(v))}\n  map <- function(f) {f((staClients+transitions)*2)}\n  tServ <- matrix(sapply(lapply(serviceDistribution, r), map, simplify=TRUE), nrow=((staClients+transitions)*2), ncol=nodes )\n  tArr <- matrix(sapply(lapply(arrivalDistribution[[1]], r), map, simplify=TRUE), nrow=((staClients+transitions)*2), ncol=length(arrivalDistribution[[2]]), dimnames=list(1:((staClients+transitions)*2), arrivalDistribution[[2]]))\n  iServ <- rep(1, nodes)\n  iArr <- rep(1, nodes)\n  rand <- r(Unif()) ((staClients+transitions)*2)\n  irand <- 1\n  simClients <- 0\n  \n  obj <- list(serviceDistribution=serviceDistribution, Servs= s, Prob=p)\n  if (historic) hist <- array(dim=c(nodes, 4, transitions), dimnames=list(1:nodes, c(\"L\", \"Lq\", \"W\",\"Wq\"), 1:transitions))\n  \n  a <- array(NA, dim=nodes)\n  for(i in arrivalDistribution[[2]]) {\n    a[i] <- tArr[iArr[i], as.character(i)]\n    iArr[i] <- iArr[i] + 1\n  }\n  \n b <- matrix(NA, nrow=maxserv, ncol=nodes)\n sysClients <- rep(0, nodes)\n  \n  while (simClients < staClients) {\n    if (sum(sysClients) > 0) {\n      indice_minimo_b <- which.min(b) #al ser los libre NA, devuelve el indice menor del que no es NA\n      indice_minimo_a <- which.min(a)\n      columna_minimo_b <- ceiling(indice_minimo_b/maxserv)\n      tmin <- min(a[indice_minimo_a], b[indice_minimo_b])\n    } else {\n      indice_minimo_a <- which.min(a)\n      tmin <- a[indice_minimo_a]\n    }\n    \n    if (tmin == a[indice_minimo_a]) {\n      simClients <- simClients + 1\n      if (sysClients[indice_minimo_a] < s[indice_minimo_a]) {\n        sysClients[indice_minimo_a] <- sysClients[indice_minimo_a] + 1\n        a <- a - tmin\n        a[indice_minimo_a] <- tArr[iArr[indice_minimo_a], as.character(indice_minimo_a)]\n        iArr[indice_minimo_a] <- iArr[indice_minimo_a] + 1\n        \n        b <- b- tmin\n        indice_minimo_nodo_minimo <- which(is.na(b[, indice_minimo_a]))\n        b[indice_minimo_nodo_minimo[1], indice_minimo_a] <- tServ[iServ[indice_minimo_a], indice_minimo_a]\n        iServ[indice_minimo_a] <- iServ[indice_minimo_a] + 1  \n      } else {\n        sysClients[indice_minimo_a] <- sysClients[indice_minimo_a] + 1\n        a <- a - tmin\n        a[indice_minimo_a] <- tArr[iArr[indice_minimo_a], as.character(indice_minimo_a)]\n        iArr[indice_minimo_a] <- iArr[indice_minimo_a] + 1\n        b <- b - tmin\n      }\n    } else {\n      sysClients[columna_minimo_b] <- sysClients[columna_minimo_b] - 1\n      b <- b - tmin\n      \n      if (sysClients[columna_minimo_b] < s[columna_minimo_b]) {\n        b[indice_minimo_b] <- NA\n      } else {\n        b[indice_minimo_b] <- tServ[iServ[columna_minimo_b], columna_minimo_b]\n        iServ[columna_minimo_b] <- iServ[columna_minimo_b] + 1\n      }\n      a <- a - tmin\n      nsim <- rand[irand]\n      irand <- irand+1\n      acumulador <- 0\n      j <- 0\n      while (acumulador < nsim) {\n        acumulador <- acumulador+ p[columna_minimo_b, j+1]\n        j <- j + 1\n      }\n      j <- j-1\n      \n      if (j > 0) {\n        sysClients[j] <- sysClients[j] + 1\n        if (sysClients[j] <= s[j]) {\n          indice_minimo_nodo_minimo <- which(is.na(b[,j]))\n          b[indice_minimo_nodo_minimo[1], j] <- tServ[iServ[j], j]\n          iServ[j] <- iServ[j] + 1\n        }\n      }\n    }\n  }\n  simClients <- 0\n  cron <- 0\n  c <- d <- entradas_nodo <- c(0, nodes)\n  prob <- matrix(c(0), nrow=transitions, ncol=nodes)\n  \n  while (simClients < transitions) {\n    if (sum(sysClients) > 0) {\n      indice_minimo_b <- which.min(b) #al ser los libre NA, devuelve el indice menor del que no es NA\n      indice_minimo_a <- which.min(a)\n      if (length(indice_minimo_b) == 0)\n        tmin <- a[indice_minimo_a]\n      else {\n        tmin <- min(a[indice_minimo_a], b[indice_minimo_b])\n        columna_minimo_b <- ceiling(indice_minimo_b/maxserv)\n      }\n    } else {\n      indice_minimo_a <- which.min(a)\n      tmin <- a[indice_minimo_a]\n    }\n    \n    if (tmin == a[indice_minimo_a]) {\n      simClients <- simClients + 1\n      entradas_nodo[indice_minimo_a] <- entradas_nodo[indice_minimo_a] + 1\n      if (sysClients[indice_minimo_a] < s[indice_minimo_a]) {\n        sysClients[indice_minimo_a] <- sysClients[indice_minimo_a] + 1\n        a <- a - tmin\n        a[indice_minimo_a] <- tArr[iArr[indice_minimo_a], as.character(indice_minimo_a)]\n        iArr[indice_minimo_a] <- iArr[indice_minimo_a] + 1\n        \n        b <- b - tmin\n        indice_minimo_nodo_minimo <- which(is.na(b[, indice_minimo_a]))\n        b[indice_minimo_nodo_minimo[1], indice_minimo_a] <- tServ[iServ[indice_minimo_a], indice_minimo_a]\n        iServ[indice_minimo_a] <- iServ[indice_minimo_a] + 1  \n      } else {\n        sysClients[indice_minimo_a] <- sysClients[indice_minimo_a] + 1\n        a <- a - tmin\n        a[indice_minimo_a] <- tArr[iArr[indice_minimo_a], as.character(indice_minimo_a)]\n        iArr[indice_minimo_a] <- iArr[indice_minimo_a] + 1\n        b <- b - tmin\n      }\n      \n      cron <- cron + tmin\n      for (j in 1:nodes) {\n        if (j == indice_minimo_a) {\n          c[j] <- c[j]+ tmin*(sysClients[j]-1)\n          if (sysClients[j]-1 > s[j])\n            d[j] <- d[j] + tmin*(sysClients[j]-1-s[j])\n          prob[sysClients[j], j] <- prob[sysClients[j], j] + tmin\n        } else {\n          c[j] <- c[j] + tmin*sysClients[j]\n          if (sysClients[j]>s[j])\n            d[j] <- d[j] + tmin*(sysClients[j]-s[j])\n          prob[sysClients[j]+1, j] <- prob[sysClients[j]+1, j] + tmin\n        }\n      }\n    } else {\n      sysClients[columna_minimo_b] <- sysClients[columna_minimo_b] - 1\n      b <- b - tmin\n      \n      if (sysClients[columna_minimo_b] < s[columna_minimo_b]) {\n        b[indice_minimo_b] <- NA\n      } else {\n        b[indice_minimo_b] <- tServ[iServ[columna_minimo_b], columna_minimo_b]\n        iServ[columna_minimo_b] <- iServ[columna_minimo_b] + 1\n      }\n      a <- a - tmin\n      nsim <- rand[irand]\n      irand <- irand+1\n      acumulador <- 0\n      j <- 0\n      while (acumulador < nsim) {\n        acumulador <- acumulador+ p[columna_minimo_b, j+1]\n        j <- j + 1\n      }\n      j <- j-1\n      nodo_transicion <- j\n      \n      if (j > 0) {\n        sysClients[j] <- sysClients[j] + 1\n        entradas_nodo[j] <- entradas_nodo[j]+1\n        if (sysClients[j] <= s[j]) {\n          indice_minimo_nodo_minimo <- which(is.na(b[,j]))\n          b[indice_minimo_nodo_minimo[1], j] <- tServ[iServ[j], j]\n          iServ[j] <- iServ[j] + 1\n        }\n      }\n      \n      cron <- cron + tmin\n      for (j in 1:nodes) {\n        if ((j==columna_minimo_b) && (j!=nodo_transicion)) {\n          c[j] <- c[j] + tmin*(sysClients[j]+1)\n          if (sysClients[j]+1 > s[j])\n            d[j] <- d[j] + tmin*(sysClients[j]+1-s[j])\n          prob[sysClients[j]+2, j] <- prob[sysClients[j]+2, j]+ tmin\n        } else {\n          if ((j == nodo_transicion) && (j!=columna_minimo_b)) {\n            c[j] <- c[j] + tmin*(sysClients[j]-1)\n            if (sysClients[j]-1 > s[j])\n              d[j] <- d[j] + tmin*(sysClients[j]-1-s[j])\n            prob[sysClients[j], j] <- prob[sysClients[j], j] + tmin\n          } else {\n            c[j] <- c[j]+tmin*sysClients[j]\n            if (sysClients[j] > s[j])\n              d[j] <- d[j] + tmin*(sysClients[j]-s[j])\n            prob[sysClients[j]+1, j] <- prob[sysClients[j]+1, j] + tmin\n          }         \n        }\n      }\n    }\n  }\n  l <- c/cron\n  lq <- d/cron\n  w <- c/entradas_nodo\n  wq <- d/entradas_nodo\n  lqt <- sum(lq)\n  rho <- l - lq\n  eff <- w/(w-wq)\n  pn <- prob/cron\n  obj$out <- list(l=l, lq=lq, lqt=lqt, w=w, wq=wq, pn=pn, rho=rho, eff=eff)\n  #obj$out$data <- array(c(l, lq, w, wq), dim= c(nodes, 4), dimnames=list(1:nodes, c(\"L\", \"Lq\", \"W\", \"Wq\")))\n  #obj$out$Lqt <- sum(obj$out$data[,1])\n  if (historic) {\n    obj$out$Historic <- hist\n  }\n  oldClass(obj) <-  c(\"Open\", \"SimulatedNetwork\", \"SimulatedModel\")\n  \n  return(obj)\n}\n\nexportToUI(OpenNetwork, \"Open Network\", c(\"Vdistr\", \"distr\", \"vector\", \"matrix\", \"numeric\", \"numeric\", \"boolean\"),  c(\"Open\", \"SimulatedNetwork\", \"SimulatedModel\"))\n\n#' Print the main characteristics of a SimulatedModel object\n#' @param x SimulatedModel object\n#' @param ... Further arguments passed to or from other methods.\n#' @method print SimulatedModel\n#' @keywords internal\n#' @export\nprint.SimulatedModel <- function(x, ...) {\n  cat(\"Model: \", class(x)[1])\n  cat(\"\\nL =\\t\", x$out$l, \"\\tW =\\t\", x$out$w, \"\\t\\tIntensidad =\\t\", x$out$rho , \"\\n\")\n  cat(\"Lq =\\t\", x$out$lq, \"\\tWq =\\t\", x$out$wq, \"\\tEficiencia =\\t\", x$out$eff, \"\\n\\n\")\n}\n\n#' Print the main characteristics of a SimulatedNetwork object\n#' @param x SimulatedNetwork object\n#' @param ... Further arguments passed to or from other methods.\n#' @method print SimulatedNetwork\n#' @keywords internal\n#' @export\nprint.SimulatedNetwork <- function(x, ...) {\n  cat(\"Model: \", class(x)[1], \"\\n\")\n  cat(\"\\nL =\\t\", x$out$l, \"\\tW =\\t\", x$out$w, \"\\t\\tIntensidad =\\t\", x$out$rho , \"\\n\")\n  cat(\"Lq =\\t\", x$out$lq, \"\\tWq =\\t\", x$out$wq, \"\\tEficiencia =\\t\", x$out$eff, \"\\n\\n\")\n  cat(\"LqT: \", x$out$lqt, \"\\n\")\n}\n\n#' Shows the main graphics of the parameters of a Simulated Model\n#' \n#' @param object Simulated Model\n#' @param range Range of the graphics\n#' @method summary SimulatedModel\n#' @param ... Further arguments passed to or from other methods.\n#' @export\nsummary.SimulatedModel <- function(object, range=NULL, ...) {\n  if (is.null(object$out$historic)) stop(\"Argument 'historic' should be TRUE to show the plots\")\n  if (is.null(range))  {\n    maxrange <- length(object$out$historic[,\"L\"])\n    minrange <- 1\n  }\n  else {\n    maxrange <- max(range)\n    minrange <- min(range)\n  }\n  par(mfrow=c(3,2))\n  barplot(object$out$historic[minrange:maxrange,\"Clients\"])\n  plot(minrange:maxrange, object$out$historic[minrange:maxrange,\"Intensity\"], type=\"l\")\n  plot(minrange:maxrange, object$out$historic[minrange:maxrange,\"L\"], type=\"l\")\n  plot(minrange:maxrange, object$out$historic[minrange:maxrange,\"Lq\"], type=\"l\")\n  plot(minrange:maxrange, object$out$historic[minrange:maxrange,\"W\"], type=\"l\")\n  plot(minrange:maxrange, object$out$historic[minrange:maxrange,\"Wq\"], type=\"l\")\n}\n\n#' Shows a plot of the evolution of L and Lq during the simulation\n#' \n#' @param object Simulated Model\n#' @param minrange Start client of simulation\n#' @param maxrange Last client of simulation\n#' @param graphics Type of graphics: \"graphics\" use the basic R plot and \"ggplot2\" the library ggplot2\n#' @export\nsummaryllq <- function(object, minrange, maxrange, graphics=\"ggplot2\") {\n  if (is.null(object$out$historic)) stop(\"Argument 'historic' must be TRUE to show the plots\")\n  data <- data.frame(n=minrange:maxrange, \"L\"=object$out$historic[minrange:maxrange, \"L\"], \"Lq\"=object$out$historic[minrange:maxrange, \"Lq\"])\n  switch(graphics,\n        \"graphics\" =  {plot(data$n, data$L, col=\"red\", type=\"l\")\n                       lines(data$n, data$Lq, col=\"blue\")\n                       legend(\"bottomright\", c(\"L\", \"Lq\"), lty =c(1,1), col = c(\"red\", \"blue\"), bty=\"n\")\n                       title(main=paste(\"Evolution of L and Lq\", sep=\"\"))},\n         \"ggplot2\" = {data <- melt(data, id.var=\"n\")\n                      qplot(n, value, data=data, geom=\"line\", colour=variable, \n                      main=\"Evolution of L and Lq.\", ylab=\"Mean customers\")})\n}\n\n#' Shows a plot of the evolution of W and Wq during the simulation\n#' \n#' @param object Simulated Model\n#' @param minrange Start client of simulation\n#' @param maxrange Last client of simulation\n#' @param graphics Type of graphics: \"graphics\" use the basic R plot and \"ggplot2\" the library ggplot2\n#' @export\nsummarywwq <- function(object, minrange, maxrange, graphics=\"ggplot2\") {\n  if (is.null(object$out$historic)) stop(\"Argument 'historic' must be TRUE to show the plots\")\n  data <- data.frame(n=minrange:maxrange, \"W\"=object$out$historic[minrange:maxrange, \"W\"], \"Wq\"=object$out$historic[minrange:maxrange, \"Wq\"])\n  switch(graphics,\n         \"graphics\" =  {plot(data$n, data$W, col=\"red\", type=\"l\")\n                        lines(data$n, data$Wq, col=\"blue\")\n                        legend(\"bottomright\", c(\"W\", \"Wq\"), lty =c(1,1), col = c(\"red\", \"blue\"), bty=\"n\")\n                        title(main=paste(\"Evolution of W and Wq\", sep=\"\"))},\n         \"ggplot2\" = {data <- melt(data, id.var=\"n\")\n                      qplot(n, value, data=data, geom=\"line\", colour=variable, \n                            main=\"Evolution of W and Wq.\", ylab=\"Mean time\")})\n}",
    "created" : 1384960766540.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1034456971",
    "id" : "4045C666",
    "lastKnownWriteTime" : 1385573870,
    "path" : "E:/Dropbox/ProyectoFC_Colas/VersionFinal/arqas/R/5_SimulateModels.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}