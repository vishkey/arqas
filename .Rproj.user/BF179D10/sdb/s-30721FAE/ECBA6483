{
    "contents" : "#' Obtains the main characteristics of a M/M/1 queueing model\n#' \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @return\n#' Returns the next information of a M/M/1 model:\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{cn}{Constant coefficients used in the computation of \\eqn{P(n)}}\n#' \\item{p0}{Probability of empty system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export\n#' @family AnaliticalModels \nM_M_1 <- function(lambda=3, mu=6) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  obj$servers <- 1\n  \n  rho <- lambda/mu\n  if (rho >= 1) {stop(\"non-stationary model\\n\")}\n  \n  l <- lambda/(mu-lambda)\n  wq <- lambda/(mu*(mu-lambda)) \n  lq <- lambda*wq\n  w <- l/lambda\n  eff <- mu*w\n  \n  obj$out <- list(rho = rho, barrho=rho, l=l, lq=lq, wq=wq, w=w, eff=eff)\n  oldClass(obj) <- c(\"M_M_1\", \"M_M_S\", oldClass(obj))\n  return(obj)        \n}\n\nexportToUI(M_M_1, \"M/M/1\", c(\"numeric\", \"numeric\"), c(\"M_M_1\", \"M_M_S\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_1\n#' @details\n#' \\code{Pn.M_M_1} implements the method for a M/M/1 queueing model\n#' @export\nPn.M_M_1 <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  \n  rho <- qm$out$rho\n  n <- floor(n)\n  if (min(n) < 0) {stop(\"P(n): Index out of limits: 0:Inf\\n\")}\n  \n  return((1-rho)*rho^n)\n}\n\n#' @rdname FW\n#' @method FW M_M_1\n#' @details\n#' \\code{FW.M_M_1} implements the method for a M/M/1 queueing model\n#' @export\nFW.M_M_1 <- function(qm, x) {\n  lambda <- rate(qm$arrivalDistribution)\n  mu <- rate(qm$serviceDistribution)\n  return(ifelse(x <0, stop(\"W(t): Index out of limits: 0:inf\\n\"), 1-exp((lambda-mu)*x)))\n}\n\n#' @rdname FWq\n#' @method FWq M_M_1\n#' @details\n#' \\code{FWq.M_M_1} implements the method for a M/M/1 queueing model\n#' @export\nFWq.M_M_1 <- function(qm, x) {\n  lambda <- rate(qm$arrivalDistribution)\n  mu <- rate(qm$serviceDistribution)\n  return(ifelse(x <0, stop(\"Wq(t): Index out of limits: 0:inf\\n\"), 1-(lambda/mu)*exp((lambda-mu)*x))) \n}\n\n#' Obtains the main characteristics of a M/M/s queueing model\n#'\n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @param s Number of servers\n#' @return\n#' Returns the next information of a M/M/s model:\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{cn}{Constant coefficients used in the computation of \\eqn{P(n)} \\eqn{C_{n}}}\n#' \\item{p0}{Probability of empty system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system  \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W - W_q)}}\n#' @export       \n#' @family AnaliticalModels \nM_M_S <- function (lambda=3, mu=6, s=2) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  if (s <= 0) stop (\"Argument 's' must be greather than zero\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  obj$servers <- s\n  \n  rho <- lambda/(mu*s)\n  \n  if (rho >= 1) {stop(\"non-stationary model\")}\n  \n  if (s < 2)\n    cn <- c(1, lambda/(s*mu-lambda))\n  else\n    cn <- c(1, lambda/((1:(s-1))*mu), lambda/(s*mu-lambda))\n  \n  cn <- cumprod(cn)\n  p0 <- 1/sum(cn)\n  \n  lq <- (cn[s+1]*lambda*p0)/(s*mu-lambda)\n  wq <- lq/lambda\n  w <- wq + 1/mu\n  l <- lambda * w\n  eff <- mu * w\n  \n  oldClass(obj) <- c(\"M_M_S\", oldClass(obj))\n  obj$out <- list(rho = rho, barrho=rho, cn = cn, p0 = p0, l=l, lq=lq, wq=wq, w=w, eff=eff)\n  return(obj)        \n}\n\nexportToUI(M_M_S, \"M/M/s\", c(\"numeric\", \"numeric\", \"numeric\"), c(\"M_M_S\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_S\n#' @details\n#' \\code{Pn.M_M_S} implements the method for a M/M/S queueing model\n#' @export\nPn.M_M_S <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  #comprobamos que el indice menor sea correcto\n  minval <- min(n)\n  if (minval < 0) stop(\"P(n): Parameter 'n' must be positive\")\n  \n  maxval <- max(n)\n  pn <- c(qm$out$p0, qm$out$p0 * qm$out$cn[-1][-qm$servers])\n  if (maxval > (qm$servers-1)) {\n    times <- maxval - (qm$servers-1)\n    pnadd <- c(pn[qm$servers], rep(qm$out$rho, times))\n    pnadd <- cumprod(pnadd)\n    pn <- c(pn, pnadd[-1])\n  }\n  return(pn[n+1])\n}\n\n#' @rdname FW\n#' @method FW M_M_S\n#' @details\n#' \\code{FW.M_M_S} implements the method for a M/M/S queueing model\n#' @export\nFW.M_M_S <- function(qm, x) {\n  lambda <- rate(qm$arrivalDistribution)\n  mu <- rate(qm$serviceDistribution)\n  if (lambda/mu == (qm$servers-1)) {\n    return(ifelse(x < 0, 0, 1-(1+qm$out$cn[qm$servers+1]*qm$out$p0*x*mu)*exp(-mu*x)))\n  }\n  else {\n    return(ifelse(x < 0, 0, 1 + ((lambda - qm$servers*mu+mu*FWq(qm, 0))/(qm$servers*mu-lambda-mu))*exp(-mu*x) + ((qm$out$cn[qm$servers+1]*mu*qm$out$p0)/(qm$servers*mu-lambda-mu))*exp(-(qm$servers*mu-lambda)*x)))\n  }\n  \n}\n\n#' @rdname FWq\n#' @method FWq M_M_S\n#' @details\n#' \\code{FWq.M_M_S} implements the method for a M/M/S queueing model\n#' @export\nFWq.M_M_S <- function(qm, x) {\n  lambda <- rate(qm$arrivalDistribution)\n  mu <- rate(qm$serviceDistribution)\n  return(ifelse(x < 0, 0, 1-qm$out$cn[qm$servers+1]*qm$out$p0*exp(-(qm$servers*mu-lambda)*x)))\n}\n\n#' Obtains the main characteristics of a M/M/1/K queueing model\n#' \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @param k Maximun size of the queue\n#' @return\n#' Returns the next information of a M/M/1/K model:\n#' \\item{rho}{Constant coefficient \\eqn{\\lambda/\\rho}}\n#' \\item{barrho}{Traffic intensity \\eqn{\\bar{\\rho}}}\n#' \\item{barlambda}{Effective arrival rate \\eqn{\\bar{\\lambda}}}\n#' \\item{l}{Expected mean number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected mean number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export \n#' @family AnaliticalModels \nM_M_1_K <- function(lambda=3, mu=6, k=2) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  if (k <= 0) stop (\"Argument 'k' must be greather than zero\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  obj$servers <- 1\n  obj$k <- k\n  \n  rho <- lambda/mu\n  \n  if (rho != 1) {\n    l <- (rho/(1-rho)) - ((k+2)*rho^(k+2)/(1-rho^(k+2)))\n    barlambda <- lambda*(rho^(k+1)-1)/(rho^(k+2)-1)\n  }\n  else {\n    l <- (k+1)/2\n    barlambda <- lambda*(k+1)/(k+2)\n  }\n  w <- l/barlambda\n  wq <- w-1/mu\n  lq <- barlambda*wq\n  eff <- mu*w\n  barrho <- barlambda/mu\n  oldClass(obj) <- c(\"M_M_1_K\", \"M_M_S_K\", oldClass(obj))\n  \n  obj$out <- list(rho = rho, barrho = barrho, barlambda = barlambda, l=l, lq=lq, wq=wq, w=w, eff=eff)\n  return(obj)\n}\n\nexportToUI(M_M_1_K, \"M/M/1/K\", c(\"numeric\", \"numeric\", \"numeric\"), c(\"M_M_1_K\", \"M_M_S_K\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_1_K\n#' @details\n#' \\code{Pn.M_M_1_K} implements the method for a M/M/1/K queueing model\n#' @export\nPn.M_M_1_K <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"P(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n\n  ifelse(n > (qm$k+1), 0, {\n      rho <- qm$out$rho\n      if (rho == 1) {\n        rep(1/(qm$k+2), length(n))\n      } else {\n        ((rho-1)/(rho^(qm$k+2)-1))*rho^n\n      } \n  })\n}\n\n#' @rdname maxCustomers\n#' @method maxCustomers M_M_1_K\n#' @details\n#' \\code{maxCustomers.M_M_1_K} implements the method for a M/M/1/K queueing model\n#' @export\nmaxCustomers.M_M_1_K <- function(qm) {\n  return(qm$k+1)\n}\n\n#' @rdname Qn\n#' @method Qn M_M_1_K\n#' @details\n#' \\code{Qn.M_M_1_K} implements the method for a M/M/1/K queueing model\n#' @export\nQn.M_M_1_K <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"Q(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"Q(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"Q(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  ifelse(n > qm$k, 0, (Pn(qm, n)/(1-Pn(qm, qm$k+1))))     \n}\n\n#Para el caso FWq usamos la version del M_M_S_K que nos hace el calculo de manera eficiente\n#' @rdname FWq\n#' @method FWq M_M_1_K\n#' @details\n#' \\code{FWq.M_M_1_K} implements the method for a M/M/1/K queueing model\n#' @export\nFWq.M_M_1_K <- function(qm, x) {\n  FWq.M_M_S_K(qm, x)\n}\n\n#La FW si que la implementamos ya que para el M_M_1_K podemos evitar la integral\n#' @rdname FW\n#' @method FW M_M_1_K\n#' @details\n#' \\code{FW.M_M_1_K} implements the method for a M/M/1/K queueing model\n#' @export\nFW.M_M_1_K <- function(qm, x) {\n  minval <- min(x)\n  if (minval < 0) {stop(\"W(t): Index out of limites: 0:Inf\\n\")}\n  \n  mu <- rate(qm$serviceDistribution)\n  A <- S <- rep(1, length(x))\n  B <- rep(Qn(qm, 0), length(x))\n  for(n in 1:qm$k) {\n    A <- A*((mu*x)/n)\n    S <- S + A\n    B <- B + Qn(qm, n)*S\n  }\n  return(1 - B*exp(-mu*x))\n}\n\n#' Obtains the main characteristics of a M/M/S/k queueing model\n#' \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @param s Number of servers\n#' @param k Maximun size of the queue\n#' @return\n#' Returns the next information of a M/M/S/K model:\n#' \\item{rho}{Constant coefficient \\eqn{\\lambda/\\rho}}\n#' \\item{barrho}{Traffic intensity \\eqn{\\bar{\\rho}}}\n#' \\item{barlambda}{Effective arrival rate \\eqn{\\bar{\\lambda}}}\n#' \\item{cn}{Constant coefficients used in the computation of \\eqn{P(n)}}\n#' \\item{pks}{Probability of \\eqn{K+s} customers in the system \\eqn{P_{K+s}}}\n#' \\item{p0}{Probability of empty system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue\\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export   \n#' @family AnaliticalModels \nM_M_S_K <- function(lambda=3, mu=6, s=2, k=3)  {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  if (s <= 0) stop (\"Argument 's' must be greather than zero\")\n  if (k <= 0) stop (\"Argument 'k' must be greather than zero\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  obj$servers <- s\n  obj$k <- k\n  \n  rho <- lambda/(s*mu)\n  if (s < 2)\n    cn <- c(1)\n  else\n    cn <- c(1, lambda/((1:(s-1))*mu))\n  \n  if (rho == 1) {\n    cn <- c(cn, k+1)\n    cn <- cumprod(cn)\n    \n    p0 <- 1/sum(cn)\n    lq <- ((k*(k+1))/2)*(cn[s]*p0)\n  }\n  else {\n    cn <- c(cn, (rho-rho^(k+2))/(1-rho))\n    cn <- cumprod(cn)\n    \n    p0 <- 1/sum(cn)\n    lq <- (((1+k*rho^(k+1)-(k+1)*rho^k)*rho^2)/((1-rho)^2))*(cn[s]*p0)\n  }\n  pks <- cn[s]*p0*rho^(k+1)\n  barlambda <- lambda*(1-pks)\n  barrho <- rho*(1-pks)\n  wq <- lq/barlambda\n  w <- wq + 1/mu\n  l <- barlambda*w\n  eff <- mu*w\n  oldClass(obj) <- c(\"M_M_S_K\", oldClass(obj))\n  \n  obj$out <- list(rho = rho, barrho = barrho, barlambda = barlambda, cn = cn, p0 = p0, pks = pks, l=l, lq=lq, wq=wq, w=w, eff=eff)\n  return(obj)\n}\n\nexportToUI(M_M_S_K, \"M/M/s/K\", c(\"numeric\", \"numeric\", \"numeric\", \"numeric\"), c(\"M_M_S_K\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_S_K\n#' @details\n#' \\code{Pn.M_M_S_K} implements the method for a M/M/S/K queueing model\n#' @export\nPn.M_M_S_K <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  \n  n <- floor(n)\n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"P(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  ifelse(n > (qm$k+qm$servers), 0, {\n      pn <- c(qm$out$p0, qm$out$cn[-1][-qm$servers]*qm$out$p0)\n      pnadd <- c(pn[qm$servers], rep(qm$out$rho, qm$servers+qm$k))\n      pnadd <- cumprod(pnadd)\n      pn <- c(pn, pnadd[-1])\n      pn[n+1]\n  })\n}\n\n#' @rdname maxCustomers\n#' @method maxCustomers M_M_S_K\n#' @details\n#' \\code{maxCustomers.M_M_S_K} implements the method for a M/M/S/K queueing model\n#' @export\nmaxCustomers.M_M_S_K <- function(qm) {\n  return(qm$k+qm$servers)\n}\n\n#' @rdname Qn\n#' @method Qn M_M_S_K\n#' @details\n#' \\code{Qn.M_M_S_K} implements the method for a M/M/S/K queueing model\n#' @export\nQn.M_M_S_K <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"Q(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"Q(n): Argument 'n' invalid\")\n  \n  n <- floor(n)\n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"Q(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  ifelse(n > (qm$k+qm$servers-1), 0, (Pn(qm, n)/(1-qm$out$pks)))\n}\n\n#' @rdname FWq\n#' @method FWq M_M_S_K\n#' @details\n#' \\code{FWq.M_M_S_K} implements the method for a M/M/S/K queueing model\n#' @export\nFWq.M_M_S_K <- function(qm, x) {\n  minval <- min(x)\n  if (minval < 0) {stop(\"Wq(t): Index out of limits: 0:Inf\")}\n  \n  mu <- rate(qm$serviceDistribution)\n  A <- S <- rep(1, length(x))\n  B <- rep(Qn(qm, qm$servers), length(x))\n  for(n in (qm$servers+1):(qm$k+qm$servers-1)) {\n    A <- A*((qm$servers*mu*x)/(n-qm$servers))\n    S <- S + A\n    B <- B + Qn(qm, n)*S\n  }\n  return(1-B*exp(-qm$servers*mu*x)) \n}\n\n#' @rdname FW\n#' @method FW M_M_S_K\n#' @details\n#' \\code{FW.M_M_S_K} implements the method for a M/M/S/K queueing model\n#' @export\nFW.M_M_S_K <- function(qm, x) {\n  minval <- min(x)\n  if (minval < 0) {stop(\"W(t): Index out of limits: 0:Inf\")}\n  mu <- rate(qm$serviceDistribution)\n  integrateaux <- function(t) {\n    fwaux <- function(x) {FWq(qm, t-x)*mu*exp(mu*x*-1)}\n    integrate(fwaux, lower=0, upper=t)\n  }\n  #Calculamos W(t) a partir de la integral\n  return(unlist(sapply(x, integrateaux)[1,], use.names=FALSE))\n  \n}\n\n#' Print the main characteristics of a M_M_S_K model\n#' @param x M_M_S_K class object\n#' @param ... Further arguments passed to or from other methods.\n#' @method print M_M_S_K\n#' @keywords internal\n#' @export\nprint.M_M_S_K <- function(x, ...) {\n  cat(\"Model: \", class(x)[1])\n  cat(\"\\nL =\\t\", x$out$l, \"\\tW =\\t\", x$out$w, \"\\t\\tIntensidad =\\t\", x$out$barrho , \"\\n\")\n  cat(\"Lq =\\t\", x$out$lq, \"\\tWq =\\t\", x$out$wq, \"\\tEficiencia =\\t\", x$out$eff, \"\\n\\n\")\n}",
    "created" : 1380888907081.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1633255153",
    "id" : "ECBA6483",
    "lastKnownWriteTime" : 1385313791,
    "path" : "E:/Dropbox/ProyectoFC_Colas/VersionFinal/arqas/R/2_SimpleModels.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}