{
    "contents" : "#' Ciclic Routing Matrix\n#' \n#' #param n Number of nodes\n#' @keywords internal\nCiclic <- function(n) {\n  diag(n)[c(2:n,1),]\n}\n\n#' Serial Routing Matrix\n#' \n#' #param n Number of nodes\n#' @keywords internal\nTamdem <- function(n) {\n  diag(n+1)[2:(n+1), 1:n]\n}\n\n#' Obtains the main characteristics of an Open Jackson network model\n#' \n#' @param lambda Vector of arrival rates at each node\n#' @param mu Vector of mean service rates\n#' @param s Vector with the number of servers at each node\n#' @param p Routing matrix, where \\eqn{p_{ij}} is the routing probability from node i to node j\n#' @return\n#' Returns the next information of an Open Jackson network model:\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{l}{Vector with the expected number of customers in the nodes \\eqn{L}}\n#' \\item{lq}{Vector of expected number of customers in the queue of each node \\eqn{L_{q}}}\n#' \\item{w}{Vector of expected waiting time in each node \\eqn{W}}\n#' \\item{wq}{Vector of expected waiting time in the queue of each node \\eqn{W_{q}}}\n#' \\item{lt}{Expected number of customers in the network}\n#' \\item{lqt}{Expected number of customers in all queues}\n#' \\item{wt}{Total expected waiting time in the network}\n#' \\item{wqt}{Total expected waiting time in all queues}\n#' \\item{eff}{Efficiency \\eqn{Eff = W/(W-W_q)}}\n#' @export\n#' @family AnaliticalModels\nOpenJacksonNetwork <- function(lambda=c(20, 30), mu=c(100, 25), s=c(1,2), p=matrix(c(0.2, 0.25, 0.1, 0), nrow=2, ncol=2)) {\n  #Comprobar parametros de entrada tienen la misma longitud, y P cumple las condiciones  \n  sizelambda <- length(lambda)\n  sizemu <- length(mu)\n  sizes <- length(s)\n  if (sizelambda != sizemu || sizelambda != sizes || sizemu != sizes)\n    stop(\"Arguments 'lambda', 'mu' and 's' must have the same length\")\n  \n  if (nrow(p) != sizes || ncol(p) != sizes)\n    stop(simpleError(paste(\"Argument 'p' must have \", sizes, \" rows and columns.\")))\n  \n  if (any(p < 0 | p > 1) || any(rowSums(p) > 1)) {\n    stop (simpleError(\"Argument 'p' must have values between 0 and 1 and each row must sum 1 or less.\"))\n  }\n  obj <- list(lambda=lambda, mu=mu, servers=s, prob=p)\n  \n  id <- diag(length(lambda))\n  A <- id-t(p)\n  \n  if (abs(det(A)) <= (.Machine$double.eps ^ 0.5)) {\n    stop(simpleError(\"Not stationary system\"))\n  }\n  # V <- c(solve(A)%*%lambda)\n  barlambda <- solve(A, lambda)\n  if (any(barlambda > mu*s)) {\n    stop(simpleError(\"Not stationary system\"))\n  }\n  obj$nodes <- mapply(M_M_S, barlambda, mu, s, SIMPLIFY=FALSE)\n  lq <- sapply(obj$nodes, function(x) x$out$lq)\n  l <- lq+(barlambda/mu)\n  w <- lq/barlambda + 1/mu\n  wq <- lq/barlambda\n  \n  lt <- sum(l)\n  lqt <- sum(lq)\n  wt <- lt/sum(lambda)\n  wqt <- lqt/sum(lambda)\n  \n  obj$A <- A\n  obj$out <- list(lq = lq, l=l, w=w, wq=wq, lt=lt, lqt=lqt, wt=wt, wqt=wqt) \n  oldClass(obj) <- c(\"OpenJackson\", \"Network\", \"MarkovianModel\")\n  return(obj)    \n}\n\nexportToUI(OpenJacksonNetwork, \"Open Jackson Network\", c(\"vector\", \"vector\", \"vector\", \"matrix\"), c(\"OpenJackson\", \"Network\", \"MarkovianModel\"))\n\n#' Data for a Open Network Example\n#' \n#' @return The solution of the example\n#' @keywords internal\nSN_Example <- function () {\n  p <- matrix(c(0.2, 0.25, 0.1, 0), nrow=2, ncol=2)\n  s <- c(1, 2)\n  lambda <- c(20 ,30)\n  mu <- c(100, 25)\n  OpenJacksonNetwork(lambda, mu, s, p)\n}\n\n#' Gets the model of the selected node\n#' \n#' @param net network\n#' @param i node\n#' @return object model\n#' @method node OpenJackson\n#' @keywords internal\n#' @export\nnode.OpenJackson <- function(net, i) {\n  if (i <= 0 || i > length(net$mu)) {stop(paste(\"node: Index out of limits: 1:\", length(net$mu), \"\\n\", sep=\"\"))}\n  \n  return(net$nodes[[i]])\n}\n\n#' @rdname Pn\n#' @method Pn OpenJackson\n#' @details\n#' \\code{Pn.OpenJackson} implements the method for an Open Jackson Network model\n#' In this function n, should have the same length than the number of nodes in the network.\n#' @export\nPn.OpenJackson <- function(qm, n) {\n  if (length(n) != length(qm$nodes)) {stop(\"P(n): Length of indexes must be equal to the number of nodes in the network\\n\")}\n  \n  probs <- mapply(Pn, qm$nodes, n)\n  return(prod(probs)) \n}\n\n#' @rdname P0i\n#' @method P0i OpenJackson\n#' @details\n#' \\code{P0i.OpenJackson} implements the method for an Open Jackson Network model\n#' @export\nP0i.OpenJackson <- function(net, i) {\n  if (i <= 0 || i > length(net$lambda)) {\n    stop(paste(\"P0i: Index out of limits: 1:\", length(net$lambda), \"\\n\", sep=\"\"))\n  }\n  return(net$lambda[i]/sum(net$lambda))\n}\n\n#' @rdname Pi0\n#' @method Pi0 OpenJackson\n#' @details\n#' \\code{Pi0.OpenJackson} implements the method for an Open Jackson Network model\n#' @export\nPi0.OpenJackson <- function(net, i) {\n  if (i <= 0 || i > nrow(net$prob)) {\n    stop(paste(\"Pi0: Index out of limits: 1:\", nrow(net$prob), \"\\n\", sep=\"\"))\n  }\n  return(1-sum(net$prob[i,]))\n}\n\n#' Computes f_i(n)\n#' \n#' @param ps partial solution of closed network\n#' @param i node\n#' @param n clients\n#' @return fi(n)\n#' @keywords internal\nf_close <- function(ps, i, n) {\n  rho <- ps$out$rho[i]\n  s <- ps$servers[i]\n  \n  f <- function(n) {\n    if (n == 0) {return(1)}\n    if (n <= s) {\n      return((rho^n)/prod(1:n))\n    }\n    else {\n      return((rho^n)/(prod(1:s)* s^(n-s)))\n    }\n  }\n  return(mapply(f, n))\n}\n\n#' Computes matrix G\n#' \n#' @param ps partial solution of closed network\n#' @return matrix G\n#' @keywords internal\ncalculateG <- function(ps) { \n  res <- matrix(c(1), nrow=ps$k, ncol=(ps$n+1))\n  for(i in 2:(ps$n+1)) {\n    res[1,i] <- f_close(ps, 1, i-1)\n    for(j in 2:ps$k) {\n      res[j, i] <- sum(res[j-1, i:1] * f_close(ps, j, 0:(i-1)))\n    }\n  }\n  return(res)\n  \n}\n\n#' Probability of i clients in the last node of the network\n#' \n#' @param ps partial solution of closed network\n#' @param i clients\n#' @return P(i) in the last node\n#' @keywords internal\npnlast <- function(ps, i) {\n  if (min(i) < 0 || max(i)>ps$n) stop(paste(\"Pnlast: Argument 'i' must be between 0 and \", ps$n, sep=\"\"))\n  return((f_close(ps, ps$k, i) * ps$g[ps$k-1, ps$n-i+1])/ps$g[ps$k, ps$n+1])\n}\n\n#' Data for a Closed Network Example\n#' \n#' @return The solution of the example\n#' @keywords internal\nCN_example <- function() {\n  mu <- c(5,5,10,15)\n  s <- c(2,2,1,1)\n  p <- array(c(0.25,0.15,0.5,0.4,0.15,0.35,0.25,0.3,0.2,0.2,0.15,0.25,0.4,0.30,0.1,0.05), dim=c(4,4))\n  nClients <- 3\n  ClosedJacksonNetwork(mu, s, p, 3)\n}\n\n#' Obtains the main characteristics of a Closed Jackson Network model\n#' \n#' @param mu Vector of mean service rates \n#' @param s Vector of servers at each node\n#' @param p Routing matrix, where \\eqn{p_{ij}} is the routing probability from node i to node j\n#' @param n Number of customers in the network\n#' @return Returns the next information of a Closed Jackson Network model:\n#' \\item{rho}{Traffic intensity \\eqn{\\rho}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export \n#' @family AnaliticalModels\nClosedJacksonNetwork <- function(mu=c(5,5,10,15), s=c(2,2,1,1), p=array(c(0.25,0.15,0.5,0.4,0.15,0.35,0.25,0.3,0.2,0.2,0.15,0.25,0.4,0.30,0.1,0.05), dim=c(4,4)), n=10) {\n  sizemu <- length(mu)\n  sizes <- length(s)\n  if (sizemu != sizes)\n    stop(\"Arguments 'mu' and 's' must have the same length\")\n  if (n < 0)\n    stop(\"Argument 'n' must be greather than 0\")\n  \n  if (any(p < 0 | p > 1) || any(rowSums(p) != 1)) {\n    stop (simpleError(\"Argument 'p' must have values between 0 and 1 and each row must sum 1.\"))\n  }\n  \n  obj <- list(mu=mu, servers=s, prob=p, n=n)\n  obj$k <- k <- length(mu)\n  trasp <- t(p)\n  id <- diag(k)\n  id <- id[-nrow(id),]\n  aux <- id - trasp[-nrow(trasp),]\n  A <- aux[,-1]\n  B <- -aux[,1]\n  \n  if (abs(det(A)) <= (.Machine$double.eps ^ 0.5)) {\n    stop(\"Not stationary system\")\n  }\n  obj$lambda <- lambda <- c(1, solve(A, B))\n  rho <- lambda/mu\n  obj$out$rho <- rho\n  \n  nodes <- matrix(c(1), nrow=k, ncol=4, dimnames=list(c(1:k), c(\"L\", \"Lq\", \"W\",\"Wq\")))\n  shiftdown <- c(k, 1:(k-1))\n  obj$out$gkn <- NULL\n  for (node in k:1) { \n    #Calculamos G\n    obj$g <- calculateG(obj)\n    if (is.null(obj$out$gkn)) obj$out$gkn <- obj$g[k, n+1]\n    l <- sum(1:n * pnlast(obj, 1:n))\n    if (node == k) {\n      barlambda <- 0\n      for (i in 1:n) {\n        if (i <= obj$servers[k]) {\n          barlambda <- barlambda + obj$mu[k]*i*pnlast(obj, i)\n        } else {\n          barlambda <- barlambda + obj$mu[k]*obj$servers[k]*pnlast(obj, i)\n        }\n      }\n      \n      c <- barlambda/obj$lambda[k]\n    } else {\n      barlambda <- c*obj$lambda[node]\n    }\n    w <- l/barlambda\n    wq <- w - (1/obj$mu[k])\n    lq <- l/w*wq\n    nodes[node,] <- c(l, lq, w, wq)\n    \n    #Desplazamos mu, rho, s Y P\n    obj$mu <- obj$mu[shiftdown]\n    obj$out$rho <- obj$out$rho[shiftdown]\n    obj$servers <- obj$servers[shiftdown]\n    obj$prob <- obj$prob[shiftdown, shiftdown]\n  }\n  #obj$out$nodes <- nodes\n  obj$out$l <- as.numeric(nodes[,\"L\"])\n  obj$out$lq <- as.numeric(nodes[, \"Lq\"])\n  obj$out$w <- as.numeric(nodes[, \"W\"])\n  obj$out$wq <- as.numeric(nodes[, \"Wq\"])\n  obj$out$lqt <- sum(obj$out$lq)\n  obj$out$lt <- sum(obj$out$l)\n  obj$out$wt <- obj$out$lt/sum(obj$lambda)\n  obj$out$wqt <- obj$out$lqt/sum(obj$lambda)\n  oldClass(obj) <- c(\"ClosedJackson\", \"Network\", \"MarkovianModel\")\n  return(obj)\n}\n\nexportToUI(ClosedJacksonNetwork, \"Closed Jackson Network\",  c(\"vector\", \"vector\", \"matrix\", \"numeric\"),  c(\"ClosedJackson\", \"Network\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn ClosedJackson\n#' @details\n#' \\code{Pn.ClosedJackson} implements the method for a Closed Jackson Network model\n#' In this function n, should have the same length than the number of nodes in the network.\n#' @export\nPn.ClosedJackson <- function(qm, n) {\n  if (length(n) != qm$k) stop(\"P(n): Argument 'n' must be a list of the same length than the number of nodes in the network\")\n  if (sum(n) != qm$n) stop(\"P(n): the sum of all values of n must be equal to the clients in the network\")\n  acum <- 1\n  for(i in 1:(qm$k)) {\n    acum <- acum * f_close(qm, i, n[i])\n  }\n  probs <- (1/qm$out$gkn)* acum\n  return(probs)\n}\n\n#' @rdname Pi\n#' @method Pi ClosedJackson\n#' @details\n#' \\code{Pi.ClosedJackson} implements the method for a Closed Jackson Network model\n#' @export\nPi.ClosedJackson <- function(net, n, node) {\n  if ((node < 1) || (node > net$k)) stop(paste(\"Pi: node must be in the range 1:\", net$k, sep=\"\"))\n  \n  #Calculammos el desplazamiento\n  if ((node+1) <= net$k) {\n    shift <- c((node+1):net$k ,1:node)\n    #Desplazamos los valores necesarios de la solucion parcial\n    net$out$rho <- net$out$rho[shift]\n    net$servers <- net$servers[shift]\n  }\n  \n  g <- calculateG(net)\n  return((f_close(net, net$k, n) * g[net$k-1, net$n-n+1])/g[net$k, net$n+1])      \n}\n\nprint.OpenJackson <- function(x, ...) {\n  cat(\"Model: \", class(x)[1], \"\\n\")\n  aux <- matrix(c(x$out$l, x$out$lt, x$out$lq, x$out$lqt, x$out$w, x$out$wt, x$out$wq, x$out$wqt), ncol=4, dimnames=list(c(as.character(1:length(x$s)), \"Total\"), c(\"L\", \"Lq\", \"W\", \"Wq\")))\n  print(aux)\n}\n\nprint.ClosedJackson <- function(x, ...) {\n  cat(\"Model: \", class(x)[1], \"\\n\")\n  aux <- matrix(c(x$out$l, x$out$lt, x$out$lq, x$out$lqt, x$out$w, x$out$wt, x$out$wq, x$out$wqt), ncol=4, dimnames=list(c(as.character(1:x$k), \"Total\"), c(\"L\", \"Lq\", \"W\", \"Wq\")))\n  print(aux)\n}",
    "created" : 1375034874792.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "647554912",
    "id" : "829E9989",
    "lastKnownWriteTime" : 1385565266,
    "path" : "E:/Dropbox/ProyectoFC_Colas/VersionFinal/arqas/R/4_NetworkModels.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}