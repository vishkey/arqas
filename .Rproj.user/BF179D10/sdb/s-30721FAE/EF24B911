{
    "contents" : "#' Obtains the main characteristics of a M/M/1/\\eqn{\\infty}/H queueing model\n#' \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @param h Population size\n#' @return\n#' Returns the next information of a M/M/1/\\eqn{\\infty}/H model:\n#' \\item{rho}{Constant \\eqn{\\lambda/\\rho}}\n#' \\item{barrho}{Traffic intensity \\eqn{\\bar{\\rho}}}\n#' \\item{barlambda}{Mean service rate \\eqn{\\bar{\\lambda}}}\n#' \\item{cn}{Constant coefficients used in the computation of \\eqn{P(n)}}\n#' \\item{p0}{Probability of empty system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export \n#' @family AnaliticalModels\nM_M_1_INF_H <- function(lambda=3, mu=6, h=5) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  if (h < 1) stop(\"Argument 'h' must be equal or greater than one\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  \n  obj$servers <- 1\n  \n  \n  obj$h <- h\n  \n  rho <- lambda/mu\n  cn <- c(1, rho*(h-(1:h)+1))\n  cn <- cumprod(cn)\n  \n  p0 <- 1/sum(cn)\n  \n  l <- sum((1:h)*cn[-1]*p0)\n  barlambda <- lambda*(h-l)\n  w <- l/barlambda\n  wq <- w - (1/mu)\n  lq <- barlambda * wq\n  eff <- mu * w\n  barrho <- rho*(h-l)\n  \n  obj$out <- list(rho = rho, barrho = barrho, barlambda = barlambda, l=l, lq=lq, wq=wq, w=w, eff=eff, p0=p0, cn=cn)\n  oldClass(obj) <- c(\"M_M_1_INF_H\", \"M_M_S_INF_H\", oldClass(obj))\n  return(obj)\n}\n\nexportToUI(M_M_1_INF_H, \"M/M/1/INF/H\", c(\"numeric\", \"numeric\", \"numeric\"), c(\"M_M_1_INF_H\", \"M_M_S_INF_H\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_1_INF_H\n#' @details\n#' \\code{Pn.M_M_1_INF_H} implements the method for a M/M/1/\\eqn{\\infty}/H queueing model\n#' @export\nPn.M_M_1_INF_H <- function(qm, n) {\n  Pn.M_M_S_INF_H(qm, n)\n}\n\n#' @rdname maxCustomers\n#' @method maxCustomers M_M_1_INF_H\n#' @details\n#' \\code{maxCustomers.M_M_1_INF_H} implements the method for a M/M/1/\\eqn{\\infty}/H queueing model\n#' @export\nmaxCustomers.M_M_1_INF_H <- function(qm) {\n  maxCustomers.M_M_S_INF_H(qm)\n}\n\n#' @rdname Qn\n#' @method Qn M_M_1_INF_H\n#' @details\n#' \\code{Qn.M_M_1_INF_H} implements the method for a M/M/1/\\eqn{\\infty}/H queueing model\n#' @export\nQn.M_M_1_INF_H <- function(qm, n) {\n  Qn.M_M_S_INF_H(qm, n)\n}\n\n#' @rdname FWq\n#' @method FWq M_M_1_INF_H\n#' @details\n#' \\code{FWq.M_M_1_INF_H} implements the method for a M/M/1/\\eqn{\\infty}/H queueing model\n#' @export\nFWq.M_M_1_INF_H <- function(qm, x) {\n  FWq.M_M_S_INF_H(qm, x)\n}\n\n#' @rdname FW\n#' @method FW M_M_1_INF_H\n#' @details\n#' \\code{FW.M_M_1_INF_H} implements the method for a M/M/1/\\eqn{\\infty}/H queueing model\n#' @export\nFW.M_M_1_INF_H <- function(qm, x) {\n  minval <- min(x)\n  if (minval < 0) {stop(\"W(t): Index out of limits: 0:Inf\\n\")}\n  \n  mu <- rate(qm$serviceDistribution)\n  A <- S <- rep(1, length(x))\n  B <- rep(Qn(qm, 0), length(x))\n  \n  if (qm$h > 1) {\n    for(n in 1:(qm$h-1)) {\n      A <- A*((mu*x)/n)\n      S <- S + A\n      B <- B + Qn(qm, n)*S\n    }\n  }\n  return(1-B*exp(-mu*x))\n}\n\n#' Obtains the main characteristics of a M/M/s/\\eqn{\\infty}/H queueing model\n#'  \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @param s Number of servers\n#' @param h Population size\n#' @return \n#' Returns the next information of a M/M/s/\\eqn{\\infty}/H model:\n#' \\item{rho}{Constant coefficient \\eqn{\\lambda/\\rho}}\n#' \\item{barrho}{Traffic intensity \\eqn{\\bar{\\rho}}}\n#' \\item{barlambda}{Mean effective arrival rate \\eqn{\\bar{\\lambda}}}\n#' \\item{cn}{Constant coefficients used in the computation of \\eqn{P(n)}}\n#' \\item{p0}{Probability of empty system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export\n#' @family AnaliticalModels\nM_M_S_INF_H <- function(lambda=3, mu=6, s=3, h=5) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  if (s <= 0) stop (\"Argument 's' must be greather than zero\")\n  if (s > h) stop(\"Argument 'h' must be equal or greater than argument 's'\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  \n  obj$servers <- s\n  \n  obj$h <- h\n  \n  rho <- lambda/(s*mu)\n  \n  cn <- c(1, (lambda/(1:s*mu))*(h-(1:s)+1), rho*(h-((s+1):h)+1))\n  cn <- cumprod(cn)\n  \n  p0 <- 1/sum(cn)\n  \n  l <- sum((1:h)*(cn[-1]*p0))\n  barlambda <- lambda*(h-l)\n  w <- l/barlambda\n  wq <- w-(1/mu)\n  lq <- barlambda*wq\n  eff <- mu*w\n  barrho <- rho*(h-l)\n  \n  obj$out <- list(rho = rho, barrho = barrho, barlambda = barlambda, l=l, lq=lq, wq=wq, w=w, eff=eff, p0=p0, cn=cn)\n  oldClass(obj) <- c(\"M_M_S_INF_H\", oldClass(obj))\n  return(obj)       \n}\n\nexportToUI(M_M_S_INF_H, \"M/M/s/INF/H\", c(\"numeric\", \"numeric\", \"numeric\", \"numeric\"), c(\"M_M_S_INF_H\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_S_INF_H\n#' @details\n#' \\code{Pn.M_M_S_INF_H} implements the method for a M/M/s/\\eqn{\\infty}/H queueing model\n#' @export\nPn.M_M_S_INF_H <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"P(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  ifelse(n > qm$h, 0, {\n    pn <- c(qm$out$p0, qm$out$cn[-1]*qm$out$p0)\n    pn[n+1]\n  })\n}\n\n#' @rdname maxCustomers\n#' @method maxCustomers M_M_S_INF_H\n#' @details\n#' \\code{maxCustomers.M_M_S_INF_H} implements the method for a M/M/s/\\eqn{\\infty}/H queueing model\n#' @export\nmaxCustomers.M_M_S_INF_H <- function(qm) {\n  return(qm$h)\n}\n\n\n#' @rdname Qn\n#' @method Qn M_M_S_INF_H\n#' @details\n#' \\code{Qn.M_M_S_INF_H} implements the method for a M/M/s/\\eqn{\\infty}/H queueing model\n#' @export\nQn.M_M_S_INF_H <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"Q(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"Q(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"Q(\", n, \"): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  return(ifelse(n > (qm$h-1), 0, ((qm$h-n)*Pn(qm, n))/(qm$h-qm$out$l)))\n}\n\n#' @rdname FWq\n#' @method FWq M_M_S_INF_H\n#' @details\n#' \\code{FWq.M_M_S_INF_H} implements the method for a M/M/s/\\eqn{\\infty}/H queueing model\n#' @export\nFWq.M_M_S_INF_H <- function(qm, x) {\n  minval <- min(x)\n  if (minval < 0) {stop(\"Wq(t): Index out of limits: 0:Inf\\n\")}\n  \n  mu <- rate(qm$serviceDistribution)\n  A <- S <- rep(1, length(x))\n  B <- rep(Qn(qm, qm$servers), length(x))\n  \n  if(qm$servers >=qm$h+2) {\n    for(n in (qm$servers+1):(qm$h-1)) {\n      A <- A*((qm$servers*mu*x)/(n-qm$servers))\n      S <- S + A\n      B <- B + Qn(qm, n)*S\n    }\n  }\n  return(1-B*exp(-qm$servers*mu*x))  \n}\n\n#' @rdname FW\n#' @method FW M_M_S_INF_H\n#' @details\n#' \\code{FW.M_M_S_INF_H} implements the method for a M/M/s/\\eqn{\\infty}/H queueing model\n#' @export\nFW.M_M_S_INF_H <- function(qm, x) {\n  minval <- min(x)\n  if (minval < 0) {stop(\"W(t): Index out of limits: 0:Inf\")}\n  \n  mu <- rate(qm$serviceDistribution)\n  integrateaux <- function(t) {\n    fwaux <- function(x) {FWq(qm, t-x)*mu*exp(mu*x*-1)}\n    integrate(fwaux, lower=0, upper=t)\n  }\n  #Calculamos W(t) a partir de la integral\n  return(unlist(sapply(x, integrateaux)[1,], use.names=FALSE))    \n}\n\n#' Obtains the main characteristics of a M/M/s/\\eqn{\\infty}/H with Y replacements queueing model\n#' \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @param s Number of servers\n#' @param h Population size\n#' @param y Number of replacements\n#' @return\n#' Returns the next information of a M/M/s/\\eqn{\\infty}/H/Y model: \n#' \\item{rho}{Constant coefficient \\eqn{\\lambda/\\rho}}\n#' \\item{barrho}{Traffic intensity \\eqn{\\bar{\\rho}}}\n#' \\item{barlambda}{Effective arrival rate \\eqn{\\bar{\\lambda}}}\n#' \\item{cn}{Constant coefficients used in the computation of \\eqn{P(n)} \\eqn{C_{n}}}\n#' \\item{p0}{Probability of 0 customers in the system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}}}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}}}\n#' \\item{eff}{Efficiency of the system \\eqn{Eff = W/(W-W_q)}}\n#' @export\n#' @family AnaliticalModels\nM_M_S_INF_H_Y <- function(lambda=3, mu=6, s=3, h=5, y=3) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  if (s <= 0) stop (\"Argument 's' must be greather than zero\")\n  if (h <= 0) stop(\"Argument 'h' must be greather than zero\")\n  if (y <= 0) stop(\"Argument 'y' must be greather than zero\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  \n  if (s > y+h) {\n    stop(\"The sum of arguments 'y' and 'h' must be equal or greater than s\\n\")\n    return()\n  }\n  else {\n    obj$servers <- s\n  }\n  obj$h <- h\n  obj$y <- y\n  \n  rho <- lambda/(s*mu)\n  if (s <= y) {\n    cn <- c(1, (h*lambda)/(1:s*mu), rep(rho*h, y-(s+1)+1), rho*(h+y-((y+1):(y+h))+1))      \n  }\n  else {\n    cn <- c(1, (h*lambda)/(1:y*mu), ((h+y-((y+1):s)+1)*lambda)/(((y+1):s)*mu), (h+y-((s+1):(y+h))+1)*rho)\n  }\n  cn <- cumprod(cn)\n  p0 <- 1/sum(cn)\n  \n  n <- y:(y+h)\n  barlambda <- lambda*(h - sum((n-y)*p0*cn[n+1]))\n  barrho <- barlambda/(s*mu)\n  n <- 1:(y+h)\n  l <- sum(n*p0*cn[n+1])\n  w <- l/barlambda\n  wq <- w-(1/mu)\n  lq <- barlambda*wq\n  eff <- mu*w\n  \n  obj$out <- list(rho = rho, barrho = barrho, barlambda = barlambda, l=l, lq=lq, wq=wq, w=w, eff=eff, p0=p0, cn=cn)\n  oldClass(obj) <- c(\"M_M_S_INF_H_Y\", \"M_M_S_INF_H\", oldClass(obj)) \n  return(obj)\n}\n\nexportToUI(M_M_S_INF_H_Y, \"M/M/s/INF/H with Y replacements\", c(\"numeric\", \"numeric\", \"numeric\", \"numeric\", \"numeric\"),  c(\"M_M_S_INF_H_Y\", \"M_M_S_INF_H\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_S_INF_H_Y\n#' @details\n#' \\code{Pn.M_M_S_INF_H_Y} implements the method for a M/M/s/\\eqn{\\infty}/H/Y queueing model\n#' @export\nPn.M_M_S_INF_H_Y <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"P(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  ifelse(n > (qm$y + qm$h), 0, {\n    pn <- c(qm$out$p0, qm$out$cn[-1]*qm$out$p0)\n    pn[n+1] \n  })          \n}\n\n#' @rdname maxCustomers\n#' @method maxCustomers M_M_S_INF_H_Y\n#' @details\n#' \\code{maxCustomers.M_M_S_INF_H_Y} implements the method for a M/M/s/\\eqn{\\infty}/H/Y queueing model\n#' @export\nmaxCustomers.M_M_S_INF_H_Y<- function(qm) {\n  return(qm$y + qm$h)\n}\n\n\n#' @rdname Qn\n#' @method Qn M_M_S_INF_H_Y\n#' @details\n#' \\code{Qn.M_M_S_INF_H_Y} implements the method for a M/M/s/\\eqn{\\infty}/H with Y replacements queueing model\n#' @export\nQn.M_M_S_INF_H_Y <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"Q(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"Q(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(paste(\"Q(n): Index out of limits: 0:Inf\\n\", sep=\"\"))}\n  \n  ifelse(n > (qm$y+qm$h-1), 0, {\n    emes <- qm$y:(qm$y+qm$h)\n    sumemes <- sum((emes-qm$y)*Pn(qm,emes))       \n    ifelse(n <= (qm$y-1), qm$h*Pn(qm, n)/(qm$h-sumemes), (qm$h+qm$y-n)*Pn(qm, n)/(qm$h-sumemes))\n  }) \n}\n\n#' @rdname FWq\n#' @method FWq M_M_S_INF_H_Y\n#' @details\n#' \\code{FWq.M_M_S_INF_H_Y} implements the method for a M/M/s/\\eqn{\\infty}/H with Y replacements queueing model\n#' @export\nFWq.M_M_S_INF_H_Y <- function(qm, x) {\n  return(FWq.M_M_S_INF_H(qm,x))\n}\n\n#' @rdname FW\n#' @method FW M_M_S_INF_H_Y\n#' @details\n#' \\code{FW.M_M_S_INF_H_Y} implements the method for a M/M/s/\\eqn{\\infty}/H/ with Y replacements queueing model\n#' @export\nFW.M_M_S_INF_H_Y <- function(qm, x) {\n  return(FW.M_M_S_INF_H(qm, x))\n}\n\n#' Obtains the main characteristics of a M/M/\\eqn{\\infty} queueing model\n#' \n#' @param lambda Mean arrival rate\n#' @param mu Mean service rate \n#' @return\n#' Returns the next information of a M/M/\\eqn{\\infty} model: \n#' \\item{rho}{Constant coefficient \\eqn{\\lambda/\\rho}}\n#' \\item{barrho}{Traffic intensity \\eqn{\\bar{\\rho}}}\n#' \\item{p0}{Probability of empty system \\eqn{P_{0}}}\n#' \\item{l}{Expected number of customers in the system \\eqn{L}}\n#' \\item{lq}{Expected number of customers in the queue \\eqn{L_{q}} (\\eqn{L_{q}=0} in this model)}\n#' \\item{w}{Expected waiting time in the system \\eqn{W}}\n#' \\item{wq}{Expected waiting time in the queue \\eqn{W_{q}} (\\eqn{W_{q}=0} in this model)}\n#' \\item{eff}{Efficiency of the system  \\eqn{Eff = W/(W-W_q)}}\n#' @export \n#' @family AnaliticalModels\nM_M_INF <- function(lambda=3, mu=6) {\n  if (lambda <= 0) stop(\"Argument 'lambda' must be greather than zero\")\n  if (mu <= 0) stop(\"Argument 'mu' must be greather than zero\")\n  \n  obj <- MarkovianModel(Exp(lambda), Exp(mu))\n  \n  barrho <- 0\n  p0 <- exp(-lambda/mu)        \n  l <- lambda/mu\n  lq <- 0\n  w <- 1/mu\n  wq <- 0\n  eff <- 1\n  obj$out <- list(rho = l, barrho = barrho, l=l, lq=lq, wq=wq, w=w, eff=eff, p0=p0)\n  oldClass(obj) <- c(\"M_M_INF\", oldClass(obj))\n  return(obj)\n}\n\nexportToUI(M_M_INF, \"M/M/INF\", c(\"numeric\", \"numeric\"),  c(\"M_M_INF\", \"MarkovianModel\"))\n\n#' @rdname Pn\n#' @method Pn M_M_INF\n#' @details\n#' \\code{Pn.M_M_INF} implements the method for a M_M_INF queueing model\n#' @export\nPn.M_M_INF <- function(qm, n) {\n  #Comprobamos que n sea entero\n  if (!all.equal(n, as.integer(n))) stop(\"P(n): Argument 'n' must be integer\")\n  if (any(is.na(n))) stop(\"P(n): Argument 'n' invalid\")\n  \n  minval <- min(n)\n  maxval <- max(n)\n  if (minval < 0) {stop(\"P(n): Index out of limits: 0:Inf\\n\")}\n  \n  lambda <- rate(qm$arrivalDistribution)\n  mu <- rate(qm$serviceDistribution)        \n  cn <- c(1, lambda/((1:maxval)*mu))\n  cn <- cumprod(cn)\n  \n  pn <- c(qm$out$p0, cn[-1]*qm$out$p0)\n  return(pn[n+1])\n}\n\n#' @rdname FW\n#' @method FW M_M_INF\n#' @details\n#' \\code{FW.M_M_INF} implements the method for a M/M/\\eqn{\\infty} queueing model\n#' @export\nFW.M_M_INF <- function(qm, x) {\n  rep(0, length(x))\n}\n\n#' @rdname FWq\n#' @method FWq M_M_INF\n#' @details\n#' \\code{FWq.M_M_INF} implements the method for a M/M/\\eqn{\\infty} queueing model\n#' @export\nFWq.M_M_INF <- function(qm, x) {\n  rep(0, length(x))\n}\n#' Print the main characteristics of a M/M/S/\\eqn{\\infty}/H model\n#' @param x a M_M_S_INF_H object\n#' @param ... Further arguments passed to or from other methods.\n#' @method print M_M_S_INF_H\n#' @keywords internal\n#' @export\nprint.M_M_S_INF_H <- function(x, ...) {\n  cat(\"Model: \", class(x)[1])\n  cat(\"\\nL =\\t\", x$out$l, \"\\tW =\\t\", x$out$w, \"\\t\\tIntensidad =\\t\", x$out$barrho , \"\\n\")\n  cat(\"Lq =\\t\", x$out$lq, \"\\tWq =\\t\", x$out$wq, \"\\tEficiencia =\\t\", x$out$eff, \"\\n\\n\")\n}\n\n#' Print the main characteristics of a M/M/\\eqn{\\infty} model\n#' @param x a M_M_INF object\n#' @param ... Further arguments passed to or from other methods.\n#' @method print M_M_INF\n#' @keywords internal\n#' @export\nprint.M_M_INF <- function(x, ...) {\n  cat(\"Model: \", class(x)[1])\n  cat(\"\\nL =\\t\", x$out$l, \"\\tW =\\t\", x$out$w, \"\\t\\tIntensidad =\\t\", x$out$barrho , \"\\n\")\n  cat(\"Lq =\\t\", x$out$lq, \"\\tWq =\\t\", x$out$wq, \"\\tEficiencia =\\t\", x$out$eff, \"\\n\\n\")\n}",
    "created" : 1380623985551.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1601632316",
    "id" : "EF24B911",
    "lastKnownWriteTime" : 1385313817,
    "path" : "E:/Dropbox/ProyectoFC_Colas/VersionFinal/arqas/R/3_ComplexModels.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}